<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/09/19/%E8%81%8C%E5%9C%BA%E5%8A%A0%E6%B2%B9%E7%AB%99/%E4%BB%8E%E9%85%9D%E9%85%BF%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%8C%E6%88%91%E4%BA%B2%E5%8E%86%E7%9A%84%E9%95%BF%E6%B2%99.NET%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%E6%88%90%E7%AB%8B%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/09/19/%E8%81%8C%E5%9C%BA%E5%8A%A0%E6%B2%B9%E7%AB%99/%E4%BB%8E%E9%85%9D%E9%85%BF%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%8C%E6%88%91%E4%BA%B2%E5%8E%86%E7%9A%84%E9%95%BF%E6%B2%99.NET%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%E6%88%90%E7%AB%8B%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>title: 从酝酿到实践，我亲历的长沙.net技术社区成立过程<br>author: 溪源<br>img: /res/20190702143924.png<br>top: true<br>cover: true<br>toc: true<br>mathjax: false<br>summary: 我们为什么要搞长沙.net社区<br>date: 2019-07-04 10:00:00<br>tags:</p><ul><li>我们为什么要搞长沙.net社区<br>categories:</li><li>家务</li></ul><h1 id="从酝酿到实践，我亲历的长沙-net技术社区成立过程-md"><a href="#从酝酿到实践，我亲历的长沙-net技术社区成立过程-md" class="headerlink" title="从酝酿到实践，我亲历的长沙.net技术社区成立过程.md"></a>从酝酿到实践，我亲历的长沙.net技术社区成立过程.md</h1><h2 id="酝酿于去年春天，方案却最终夭折"><a href="#酝酿于去年春天，方案却最终夭折" class="headerlink" title="酝酿于去年春天，方案却最终夭折"></a>酝酿于去年春天，方案却最终夭折</h2><p>回到一年前的四月初，也是这样一个气象更新，春意盎然的一年中最好的时光。<br>在长沙.NET技术圈中，有一个不知名的QQ群，叫做放肆.NET技术交流群，群主锋哥和群的高管老郭我们认识了许多年，除了他两位之外，同时在这个群里面我也认识了许多朋友，包括我的朋友嘉鹏和财哥，我们一起通过互联网交流技术，探讨人生，还多次组织了线下的饭局活动，大家长期保持着密切的基友情谊。而在去年4月的时候，我们大家都想拉着长沙的.NET开发者们想搞一次技术交流活动，为此我和嘉鹏一起花了不少时间，精心编写了一个《长沙.NET技术分享交流活动》的策划案，并寻求了一些朋友的帮助，计划在2018年7月15日组织一次长沙.NET技术圈的交流活动。<br>然而最终由于我们几位虽然也通过结识一些技术企业的朋友，并跟他们交流这种活动，获得了他们的认可，但是我们都是传统企业开发者的小圈子、不认识有影响力的大牛，最终没有足够的能量把这件事情组织起来而最终搁置。对于这件事情，我一直耿耿于怀，最终我离开了星沙、离开舒适区，来到了长沙的IT聚集地麓谷，选择了一家互联网企业，渴望通过自己的努力，进一步提高自己的技能，去认识更多优秀的朋友，真正的把技术圈子拉起来。</p><h2 id="时不我待，今春的转机终于出现"><a href="#时不我待，今春的转机终于出现" class="headerlink" title="时不我待，今春的转机终于出现"></a>时不我待，今春的转机终于出现</h2><p>离开舒适区，加入互联网企业之后，虽然公司的技术体系并没有想象中开放，但是由于接触了一些圈子，也进一步打开了自己的眼界，通过自主学习和吸收公司的技术为我的技术积累本身也带来了一些与传统软件企业截然不同的体会。当时博客园成为我学习的一个阵地，在这里，我经常通过阅读一些互联网开发者们编写的博客来获取知识，同时自己也会偶尔发表一些博客来总结自己的思维，当然，我的博客园账号实际上注册的时间已经超过8年，但是过去7年却从来没有发表过一篇博客。当然，在过去七年我的文档虽然写了许多，但是这些文章大多都是企业级信息化中的建设方案这些假大空的说明文，而不是有干货的技术博客。（时至今日，这也是一段遗憾，我的博客，依然干货太少，成为许多朋友的槽点）<br>十二月初的一天无意中看到了一篇博客，介绍他们公司使用的容器实践的过程，而作者是来自于心莱科技的雪雁，也就是李文强，是心莱科技的CEO，而公司恰好又是在湖南长沙，于是我毫不犹豫的与作者牵线，互相寒暄之后，跟他沟通起我的想法来。而李文强十二月则刚好参加了腾讯云加社区组织的技术活动，并与张善友老师碰了头，当时张老师拍着文强的肩膀说，让他回长沙把社区拉起来。在这样的契机之下，我们双方一拍即可，很快就线下碰面，共同探讨了对于长沙.NET技术社区的发展方向来。<br>除了通过博客园认识了文强差不多同时，还认识了另外一位朋友，也就是我曾经专门撰文描述过的开发者邹琼俊老师，这段认识的经历在博客《我们身边那些优秀的开发者-邹琼俊》中也提到过，这里就不再赘述。在认识琼俊之后，我跟他表达了相同的想法，然后他介绍了他的老师给我，也就是我们后来组建的长沙社区的核心专家，周尹老师。而在我认识周尹老师，加了他的微信之后，发现我之前已经经常在长沙本地的技术群中与他的小号微信交流，但是没有添加好友，而且他的朋友中还有好几位也是我的朋友，这简直是一段孽缘。他对我的想法也非常认同。除此之外，我、文强和周老师相继邀请自己身边对成立社区有兴趣的朋友，组建了一个社区筹备的小群，我们相约，年后要把这个社区组织起来。<br>过年前，彼时恰好也赶上了一个时机，即在广州、深圳的引领之下，苏州的社区活动也刚刚举办，在.NET技术圈，各地都充满了建设社区的热潮。而苏州社区，作为今年新成立的社区，一出手就高逼格，无论是宣传工作，还是内容建设都堪称中国.NET社区建设的典范。于是我向张善友老师请教苏州社区的经验，并说我想仿照苏州社区的形式，在长沙把社区真正拉起来。于是张老师推荐了苏州社区的潘淳老师和广州社区的叶老师，以及Azure云技术社区的许总，同时以及全国各地的.NET社区发起者们，大家一起给我们解答疑惑，鼓励我把社区拉起来。<br>在大家的鼓励下，趁着过年的时光，筹备组的各位朋友们完成了从线上到线下的过程，在年后的2月17日安排了社区筹委会的第一次面基，当天一起参加小聚会的有十多位，包括周老师、文强和文强的朋友周鹏、年轻的开发者杨勇、孙夏、郭阁以及吴传坚等等。<br>而见到孙夏的第一时间，我觉得这位大哥很面熟，然后他说他是我一位同事的老公，这让我觉得又是一段孽缘，在2015年7月的某几天，他曾经多次来我待过多年的公司楼下，与他的夫人共进午餐，我曾经见过他几次，不过不久后，我便从这家公司离职，因此当时并不熟。而今年的这次聚会，让我正式认识了他，所以我认为，这种莫名其妙的缘分，既是一种缘分，更是优秀开发者的相互吸引。<br>在会后，我写了社区建设的第一篇文章，《我们为什么要搞长沙.NET技术社区（第一篇）》，这篇文章介绍了我们当时聚会的议题和想法，发表在博客园，并建立了微信群。而这个微信群的宣传效果非常好，两天就突破了500人群的大关，而到今天，由于我们刻意控制人数，所以群的规模稳定在750人左右。通过微信群我们感受到了长沙.NET技术圈的力量，让我们得以坚持我们的想法，把社区的种子种了下去。<br>在此之后，我们又组织了几次小范围的聚会，组织了一支十人左右的小团体，大家都承诺，未来会积极参与社区建设，为社区做出一些贡献，并有了《我们为什么要搞长沙.NET技术社区》的另外三篇。我们选出了TVP李文强老师作为我们的社区执行会长，而本人则负责秘书工作我们也初步拟定了一支小的团体，由于暂时没有更好的名字，先称呼为：发起人小组。当然，发起组织小团体的开发者，或许并非BAT大厂出身，但是大家都有一个共同的特点，就是愿意钻研技术，并希望通过自己的努力共同为长沙的技术社区抛转引玉，为技术圈的蓬勃发展提供便利。<br>在形成了一个小的社区组织后，我们于3月10日组织了第一次线下技术沙龙，这次技术沙龙作为我们的一次小试点，以收费的形式进行，而参加这次活动报名人数将近30人，参会的达到20人，总体上符合我们的预期，由于时间仓促，准备不周，我们准备的内容可能相对来说不太优质，总体上没有取得预想的效果。不过，这也为我们组织下一次活动提供了一次可以参考的原型。（不过，这大概是一次快速开发原型，而当时的我们还没有想到，最终我们操办的实际项目，是一个体量十倍的项目。）</p><h2 id="一次活动，阳春下紧锣密鼓的筹备"><a href="#一次活动，阳春下紧锣密鼓的筹备" class="headerlink" title="一次活动，阳春下紧锣密鼓的筹备"></a>一次活动，阳春下紧锣密鼓的筹备</h2><p>在3月10日下午，散会之后我们几位对成立社区充满激情的开发者们有了一次小范围的聚会，当时我跟大家说，不管成功与否，我们都必须做一次更加正规的社区成立仪式，人数可以少一点，80-100人就够了，通过这样一次仪式感，将极大的提高我们的影响力，才能更好的开展以后的安排。大家对这个想法深表认同，纷纷表示，要利用一切可以团结的力量，尽快把这个事情组织起来。<br>最开始我设想4月6日的清明节期间，而锋哥说，如果选清明节可能会耽误大家回家探亲，不太便于活动的开展，不如挑选一个稍微靠后一点的日子，而且这个日子应该有一些寓意、例如1024这种程序员的独特含义，或许更好。我也根据锋哥的想法适时调整了方案，而文强老师也开动了他的资源去寻找更多的活动伙伴，以便通过大家的努力共同把活动拉起来。而云加社区，作为国内最为开放的技术社区，因为之前跟文强一直有联系，而且他们也一直非常积极参与社区文化，我们的活动便恰当好处了进入了云加社区的合作范围。<br>在三月底左右，我们把活动的总体方案和计划初步制定了下来，并按计划逐步的协调资源，寻求进一步的安排。而在方案确定之后，获得了来自华邦互联的赵总为我们提供的第一笔赞助，以及社区的朋友为我们提供的支持让我们有了能够运营下去的启动资金，而来自微软Azure云技术社区的许豪许总也向我们承诺，能够提供一定的资金支持让我们解决了燃眉之急。<br>从内容上，我们有幸邀请到了张善友老师、梁桐铭老师和汪鹏老师。三位老师不仅仅是我们技术之路上的良师益友，对社区更是充满了热忱。我们邀请他们来长沙参加活动，他们毫不犹豫的答应了。<br>在清明节期间，文强通过与云加社区产品经理Dora女士进一步交流，文强和云加社区把活动时间定在了4月21日，而云加社区对我们的活动支持力度之大让我们之前始料未及，不仅仅可以提供场地，还能从腾讯云邀请两位专家来，这让我们有足够的信心将活动规模做得更大，而活动场地足够支持800人，不过我们大概没那么多的用户，因此我们将活动规模定在上限400人。<br>由于这次活动的规模比较大，因此我们对于资金也有迫切的需求，而之前我们只筹集了预算的一半（不到五千块钱），所以哪怕身为开发者的我们也需要放下身段，去找企业寻求资金支持。非常庆幸，长沙技术社区的优秀企业非常多，而且他们对我们的理念也非常认同。除了刚刚提到的华邦互联外，还有百师通教育长沙分公司，在得知我们需要赞助支持之后，毫不犹豫的就为我们提供了赞助，这让我们非常感动；校管家的伍总也同样如此，锋哥跟他简单的提了一下，公司老总就批条子说公司可以提供赞助；深圳纵网湖南分公司也是如此，孙夏刚开口，就获得了老板对于活动的大力支持；而岳阳北大青鸟不仅仅在活动的发起过程中帮我们努力宣传，更是主动的为我们提供了赞助；而创业者王轲王总，一开始就看好我们的活动，更是为我们想了许多办法，还提供了资金支持；长沙冉星科技，不仅仅是问卷市场的领导者，他们更是表态，愿意积极参与社区未来的活动，并在这次活动中为我们提供了礼品；当然心莱科技的力度同样很大，不仅全员参与，还为我们提供了资金支持。这些优秀企业们以其开阔的格局和优秀的互联网视野，让他们在业务层面足以成就辉煌，也能够成为未来优秀开发者们选择的梧桐佳木。</p><h2 id="4月21日，一场技术的饕餮盛宴就此拉开帷幕"><a href="#4月21日，一场技术的饕餮盛宴就此拉开帷幕" class="headerlink" title="4月21日，一场技术的饕餮盛宴就此拉开帷幕"></a>4月21日，一场技术的饕餮盛宴就此拉开帷幕</h2><p>坦率而言，由于之前的计划是一次一百人规模的活动，而扩充到300人，如果纯粹靠996或者8106开发者们的兼职谋划，几乎不可能，还好我们这次活动有幸得到了心莱科技的帮助。心莱科技全体员工，利用他们的业余时间，为我们设计海报、宣传和协调资源，才得以推动活动的快速推进。经过心莱科技和社区发起人大家的积极努力，以及与云加社区、中国.NET社区的老师们紧锣密鼓的磋商，我们在终于在4月19日完成了活动细节和海报的制作，并将海报放置在腾讯众创空间，一时间获得了在中电软件园上班的开发者们的持续关注。而嘉鹏同学不愧为长沙.NET技术全最有才气的开发者，他的圈子也同样充满了才气，在他的协助下，我们有幸邀请到来自湖大播音系的海鑫同学与他一起作为活动主持，也让我们获得了足够的人气。<br>4月20日下午，我们筹备组的全体人员放弃了休息时间，来到活动场地进行场地的布置和排练，一直持续到晚上10点半。<br>这次活动，从四月十日左右开始报名，而两天内报名的人数已经突破了150人，随后，腾讯云加社区的报名通道也开放，截止到4月20日，报名人数已经突破了400人大关，这在国内的.NET社区技术活动中，也属于报名人数比较大的规模，到4月21日当天，参加活动的人数，超过了240人，同时我们也在腾讯云加社区提供了直播，通过统计，通过云加观看我们活动实况直播的总点击量突破了千人次，一时间成为朋友圈的话题。<br>这次活动过程中，既有来自目前.NET Core技术方向的技术分享，也有来自腾讯云技术专家的AI和物联网方面的分享。张善友老师的技术分享作为开场，虽然主讲话题非常主流，但是在长沙却处于很尴尬的局面，听过.NET Core的或许不少，但是用过容器的却非常少，而k8s这种新技术，对参会的许多人来说简直闻所未闻。最近在技术层面颇有心得的梁桐铭老师，分享了他对于.NET Core的理解，这个课题，精彩和生动，他深入浅出的技术讲授，不仅让开发者们明白了.NET Core的基础知识，也让大家进一步对.NET Core的大范围应用充满了期待。而出生岳阳的汪鹏老师为了这次活动，做了非常充足的准备，他制作了一份超过30页的PPT，将IdentifyServer4的方方面面介绍得很详细。<br>下午场的AI和物联网，作为最流行的主题方向，同样吸引了不少开发者的目光，卓伟老师和胡李伟老师，他们都善于掌握现场，通过他们的介绍，让大家对腾讯云的AI产品和物联网产品有了深入的了解。不过由于种种原因，这次活动的下午场相对来说参与人数则比上午场有所偏少，主要是因为参会人群依然以.NET开发者居多，而AI和物联网技术固然市场前景广阔，但是在长沙做基础技术研究的企业并不多，因此对这些底层技术方面感兴趣的开发者是凤毛麟角。即便如此，下午的活动也获得了大家的认可，我们有理由相信，这一块的用户需求将有希望进一步挖掘。<br>有关活动的具体议题，大家可以看活动的纪实和活动相关的资料和视频回放，限于篇幅，这里就不再赘述了。</p><h2 id="大家一起，社区才更加美好"><a href="#大家一起，社区才更加美好" class="headerlink" title="大家一起，社区才更加美好"></a>大家一起，社区才更加美好</h2><p>当活动结束，再来回顾这段过程，或许每个人都有自己的收获。首先，对于闭塞的长沙.NET技术圈而言，甚至哪怕内地的技术圈而言，实际上都很少有这种技术交流，意味着我们其实依然很闭塞，如果你不交流，你或许会更加闭塞。<br>例如，我们这次活动分享的第一场活动，容器和kubernetes，曾经接触过这些技术的开发者凤毛麟角，更不用说有机会实践这些技术的，所以通过这样的活动，让我们能够进一步接触之前没有机会接触的领域，让我们的格局和视野进一步开阔，然后假以时日，如果有幸遇到一些机会能够实践这些技术，会让我们企业的技术栈更加的趋于先进和成熟；下午场的AI或物联网专场，虽然长沙有不少类似的物联网开发的企业，但大家的典型特征是从应用层面铺设备。当然，必须承认，有人承认工业互联网的依然是姓工，即满足工业环境下、工业应用的实际需求才是工业互联网和物联网的核心，但是作为巨头的腾讯，目前的主要发力方向也是企业级市场，物联网领域是腾讯未来的主攻方向，腾讯是如何将物联网和互联网相结合，实际上对于长沙的企业级物联网开发者来说，有一些共同性，他山之石可以攻玉，一定有许多值得我们学习的地方。<br>我认为参加活动的最直接收获，就是我们打开圈子能获得的体会，将有利于我们的发展。每一次技术活动，其实都是一次社交活动，在我们过去的若干年，或许认识新朋友，往往都是职场，而通过社区活动，我们将有更多机会认识技术圈志同道合的开发者，这将让我们未来获益匪浅。<br>在过去若干年间，对每家优秀的企业来说，面临的类似的问题往往都是优秀的人才何处寻觅的问题，而随着社区的建立、开源项目、优秀技术内容的建设，将形成虹吸效应，实现外来优秀开发者的聚集。同时，由于社区本身凝聚了一群优秀的开发者，他们的示范带头作用也会间接的影响目前社群中的其他开发者，让他们随之成长，而这些开发者们成长最大的获益者，显然依然是那些积极参与社区的优秀的企业。<br>作为一个草根出生的开发者，我很荣幸能够参与到这次盛会之中，亲历社区从酝酿到初生的全过程，这也让我深刻的意识到自身的不足，我也明白唯有更加积极努力的学习，才能够成就更加优秀的个体。<br>我深知如果闭门造车，容易陷入空喊口号的问题，我希望大家期待为社区做出更大的贡献,只有大家都积极参与，才有社区的今天和更加美好的名天。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>职位每周荐20190914</title>
      <link href="/2019/09/14/%E8%81%8C%E4%BD%8D%E6%8E%A8%E8%8D%90/%E8%81%8C%E4%BD%8D%E6%AF%8F%E5%91%A8%E8%8D%9020190914/"/>
      <url>/2019/09/14/%E8%81%8C%E4%BD%8D%E6%8E%A8%E8%8D%90/%E8%81%8C%E4%BD%8D%E6%AF%8F%E5%91%A8%E8%8D%9020190914/</url>
      
        <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>感兴趣的朋友可以看看智能制造之家为您精心准备的职位哦，推荐朋友入职可以享受1000-10000元的推荐费哦，更多职位，请关注微信公众号：智能制造之家，每周推送智能制造相关职位，更有大咖个人分享，名企内推哦</p><h3 id="职位列表"><a href="#职位列表" class="headerlink" title="职位列表"></a>职位列表</h3><h3 id="〉〉〉-LED资深产品经理〈〈〈"><a href="#〉〉〉-LED资深产品经理〈〈〈" class="headerlink" title="〉〉〉 LED资深产品经理〈〈〈"></a>〉〉〉 LED资深产品经理〈〈〈</h3><p>北京</p><p>岗位职责：</p><p>（1）负责事业群小间距LED产品的资源整合导入和自研产品规划工作；<br>（2）负责mini LED和micro LED的技术预研、信息收集和调研工作；<br>（3）负责事业群小间距LED产品重大项目的方案设计和技术支撑工作；<br>（4）深入调研并分析小间距LED行业竞品、对标企业等情况，为事业群LED产品规划和市场销售政策提供依据支撑；<br>（5）负责组织产品沟通会，定期探讨产品整合及规范方向，并协调各事业部、开发、品质、供应链、工厂等组织推动产品企划和上市；<br>（6）负责编制事业群小间距LED产品的产品技术路线图，制定产品规划和迭代路线；<br>（7）联动供应链、开发组织，对行业优质资源进行调研、寻源和导入，提升公司小间距LED产品的竞争力；<br>（8）负责制作产品培训资料，并定期对各业务部门进行产品培训，提升业务部门方案设计和项目支撑能力。</p><p>岗位要求：</p><p>5年以上LED行业工作经验；<br>担任过公司小间距LED产品经理岗位，并有实际产品设计者优先；<br>有过大型LED项目实施经验，并担任项目经理者优先；<br>熟悉室内小间距LED、户外LED、透明LED等显示产品，有很强的行业资源整合能力，对上游灯厂、驱动IC厂、通讯板卡厂、模具厂等，有较强的资源储备；<br>熟悉SMD、COB等不同封装工艺的小间距LED产品特点，了解mini LED、micro LED产品技术现状及未来发展趋势。<br>所需专业: 电子信息工程等理工科专业即可<br>语言要求:英语熟练掌握</p><p>薪酬福利：</p><p>年薪:25-40万   </p><p>其它：</p><h3 id="〉〉〉工艺高级工程师〈〈〈"><a href="#〉〉〉工艺高级工程师〈〈〈" class="headerlink" title="〉〉〉工艺高级工程师〈〈〈"></a>〉〉〉工艺高级工程师〈〈〈</h3><p>江西上饶</p><p>岗位职责：</p><p>1.本科以上学历，物理学、半导体、微电子学、化学、材料学、光学等专业教育背景；<br>2.电池4年以上工作经验，熟悉电池全道工序，精通擅长电池工艺（清洗/制绒/刻蚀/PE/丝网/烧结）之一；<br>3.具备较强的逻辑思维和问题分析能力，善与人沟通、组织协调能力强;<br>4.有一定的团队管理经验。</p><p>岗位要求：</p><p>1、协助经理检查、监督各项SOP的执行情况<br>2、协助经理解决产线的异常，为达到公司KPI要求努力<br>3、制定月度、季度、年度培训计划，并督导实施.<br>4、负责产线异常的处理<br>5、负责出现异常时与其他部门进行协调工作<br>6、负责协助工程师进行工艺改善、降本增效改进<br>7、及时向直接上级汇报本部门的真实情况和有关数据，定期向直接上级述职；<br>8、完成直接上级交办的其他临时工作。</p><p>薪酬福利：</p><p>年薪:15-22万   </p><p>该岗位还可享受政府购房补贴，硕士学历20W，本科学历10W。</p><p>###〉〉〉新能源研发工程师〈〈〈</p><p>江西上饶</p><p>岗位职责：</p><p>1，通过交叉实验分析失效原因；<br>2、解决产线重大反馈于部门的异常；<br>3、负责跟相关部门的沟通、协调；<br>4、负责部门工序工作的综合管理。</p><p>岗位要求：</p><p>1，本科以上学历，材料、物理、化学相关专业；<br>2，两年以上电池工作经验；<br>3，能独立负责前道（清洗/制绒/刻蚀/PE）的导入和分析；<br>4，对电池性能分析能力强，<br>5，能独立指导助工完成数据库的建立。</p><p>薪酬福利：</p><p>年薪:16-30万</p><p>其它：</p><p>光伏电池两年以上研发经验，精通擅长电池工艺前道（清洗/制绒/刻蚀）之一</p><h3 id="〉〉〉-物流-仓储工程师〈〈〈"><a href="#〉〉〉-物流-仓储工程师〈〈〈" class="headerlink" title="〉〉〉 物流/仓储工程师〈〈〈"></a>〉〉〉 物流/仓储工程师〈〈〈</h3><p>河北保定（主机厂）</p><p>岗位职责：</p><p>1.熟悉现代物流仓库管理流程和国内外仓储发展走向，有较成熟系统的管理方法，根据集团战略统筹制定年度仓储物流运营计划；<br>2.对库容优化有所建树，仓库网络布局、仓库设置、仓库管理系统配置的经验，对各项业务及流程具有知识前瞻性，可以对供应链各环节进行过程优化同时进行标准化；<br>3.可对经济批量排程方法实际应用、优化生产计划、采购计划、正逆向物流和订单履行各业务环节监控管理，保证订单保质保量的交付及逆向订单的退回；<br>4.熟悉供应链规划与执行管理，对供应链信息系统建设和工作流程优化有丰富的经验；<br>5.控制仓储、物流成本，在人效、库容、单均成本等各方面进行有效控制；<br>6.熟悉精益生产、JIT等生产物流理念，并可以进行现场应用；<br>7.规划智能化物流模式，可以输出物流信息化建设解决方案。</p><p>岗位要求：</p><p>学历：大专及以上学历<br>专业：物流管理<br>性别：男<br>年龄：35岁以上<br>工作经验：在大型汽车内、外部物流版块从事供应链管理经验5年以上，外企、合资企业工作经验优先；</p><p>薪酬福利：</p><p>年薪:15-30万   </p><p>其它：</p><p>最好仓储、物流两个方面的经验都要有</p><h3 id="〉〉〉-工艺经理〈〈〈"><a href="#〉〉〉-工艺经理〈〈〈" class="headerlink" title="〉〉〉 工艺经理〈〈〈"></a>〉〉〉 工艺经理〈〈〈</h3><p>河北保定（主机厂）</p><p>岗位职责：</p><p>1、负责公司电池工艺的维护.组织好编制和修订各项工艺参数,并对其进行有效稳定控制。</p><p>2、制定产品性能升级创优规划及性能改进措施计划,组织解决产品制造中的异常问题,负责工艺管理的工艺员技术指导,督促检查各项质量规划的实施。<br>3、负责组织建立健全公司电池工艺管理制度协调技术的关系,及时组织解决生产中的工艺维护稳定问题.<br>4、组织主持工艺工作例会并督促检查和考核例会决议执行情况,保证在生产经营过程中工艺控制工作的完成.<br>5、厉行节约,杜绝浪费,搞好综合利用.抓好物资管理,降低物耗成本,确保目标利润的实现.<br>6、参与组织工艺的业务培训工作,提高公司技术人员的总体素质.</p><p>岗位要求：</p><p>1、本科及以上学历，物理、材料、高分子、光伏等理科类专业。<br>2、电池工艺技术5年以上，熟悉制绒、刻蚀、扩散、镀膜、丝网印刷等整条电池线生产工艺及流程。<br>3、行业TOP10企业主管、经理级工艺管理经验。<br>4、较强的分析、沟通、协调能力,具有团队精神和团队领导能力。</p><p>薪酬福利：</p><p>年薪:30-50万</p><p>其它：</p><p>熟悉晶硅电池工艺技术（制绒、刻蚀、扩散、镀膜、丝网印刷等）整条电池线生产工艺及流程。</p><h3 id="〉〉〉-自动化工程师（专家）〈〈〈"><a href="#〉〉〉-自动化工程师（专家）〈〈〈" class="headerlink" title="〉〉〉 自动化工程师（专家）〈〈〈"></a>〉〉〉 自动化工程师（专家）〈〈〈</h3><p>青岛</p><p>岗位职责：</p><p>1、负责中央空调的自动化项目规划、方向性评估及应用推广；<br>2、负责新项目的机械设计、电气设计、软件设计的指导与推动工作，满足进度、质量、成本、安全等要求。 </p><p>岗位要求：</p><p>1、熟悉行业内自动化产业发展方向，具有较强的自动化机械、电气、软件的设计、规划、系统整合能力，从事自动化研发、设计、项目实施工作8年以上并取得显著工作成绩及丰富的工作经验，对信息化软件设计方面有参与或独立设计信息化软件工作经验；<br>2、能够对内部（产品相关问题）及外部因素（外部合作厂家、新技术、可替代性方案等）进行分析与把控，并且能够识别项目技术的关键点和重点难点，提出改善与优化方案；<br>3、具有很强的创新能力，对新项目的规划及设计具有前瞻性及大局观；<br>4、熟练运用office办公软件，CAD、SolidWorks等绘图软件，PLC编程软件，熟悉机器人应用，视觉应用等。从事过动态3D模拟仿真设计者优先；<br>5、学历要求：本科以上，专业：机电一体化、机械设计及自动化等相关专业。</p><p>薪酬福利：</p><p>年薪:18-30万</p><p>其它：</p><h3 id="〉〉〉主回路硬件工程师（变频器）〈〈〈"><a href="#〉〉〉主回路硬件工程师（变频器）〈〈〈" class="headerlink" title="〉〉〉主回路硬件工程师（变频器）〈〈〈"></a>〉〉〉主回路硬件工程师（变频器）〈〈〈</h3><p>北京</p><p>岗位职责：</p><p>u 负责主回路的可行性分析、元器件及功率器件的选型；</p><p>u 负责设计详细的原理图以及负责跟踪PCB设计；</p><p>u 负责调试并测试所开发的硬件电路；</p><p>u 协助结构工程师完成设计工作；</p><p>u 负责产品设计文件的编写工作及产品技术文件的校对工作；</p><p>u 解决产品生产、使用过程中出现的与设计相关的技术问题；</p><p>u 协助工艺进行改制工作以及辅助处理测试与试验工作；</p><p>岗位要求：</p><p>教育背景：自动化、电力电子等相关专业硕士以上学历，或本科学历并具有2年以上工作经验；</p><p>工作经验：有逆变器/UPS电源研发2年以上工作经验;熟悉ARM 或DSP软件开发，具有2年以上ARM或DSP硬件开发经验具有独立开发能力,了解常用单片机结构，熟悉至少1种单片机及其外围电路，熟悉常用通信电路，如I2C,SPI,UART，CAN、485等；</p><p>熟悉电机驱动类产品主功率拓扑及IGBT、电容等器件选型；熟练掌握开关电源、功率驱动、采样电路、编码器调理等电路设计；</p><p>熟悉电机驱动类产品EMC和安规规范；</p><p>技能/能力：熟悉硬件开发常用的工具软件，如：pads或者mentor；熟悉半导体功率器件的原理和特性，对变频器的硬件结构具有深入的认识，对变频器的主回路设计具有丰富的设计经验；对EMC、安规有一定了解；精通电力电子变流技术，熟悉单相或三相逆变电路的参数计算、设计和调试。</p><p>薪酬福利：</p><p>年薪:18-20万</p><p>其它：</p><p>必备条件 /核心技能产品为电梯一体机，需要有变频器、逆电器硬件相关经验。客户喜好/优先条件ABB、施耐德、汇川电机出身优先</p><h3 id="加入我们，拓展你的职业圈"><a href="#加入我们，拓展你的职业圈" class="headerlink" title="加入我们，拓展你的职业圈"></a>加入我们，拓展你的职业圈</h3><p> 如果你对智能制造感兴趣，请添加本站微信公众号：智能制造之家，来自大众，通用，福特，吉利，西门子，华为，阿里巴巴，腾讯，罗克韦尔等众多名企内推通道等着你。</p><p><img src="/wechat.jpg" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 职位推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职位推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft REST API指南</title>
      <link href="/2019/08/02/%E6%8A%80%E6%9C%AF%E8%AE%BA%E5%9D%9B/Microsoft%20REST%20API%E6%8C%87%E5%8D%97/"/>
      <url>/2019/08/02/%E6%8A%80%E6%9C%AF%E8%AE%BA%E5%9D%9B/Microsoft%20REST%20API%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Microsoft-REST-API指南"><a href="#Microsoft-REST-API指南" class="headerlink" title="Microsoft REST API指南"></a>Microsoft REST API指南</h1><h2 id="Microsoft-REST-API指南工作组"><a href="#Microsoft-REST-API指南工作组" class="headerlink" title="Microsoft REST API指南工作组"></a>Microsoft REST API指南工作组</h2><table><thead><tr><th>Name</th><th>Name</th><th>Name</th></tr></thead><tbody><tr><td>Dave Campbell (CTO C+E)</td><td>Rick Rashid (CTO ASG)</td><td>John Shewchuk (Technical Fellow, TED HQ)</td></tr><tr><td>Mark Russinovich (CTO Azure)</td><td>Steve Lucco (Technical Fellow, DevDiv)</td><td>Murali Krishnaprasad (Azure App Plat)</td></tr><tr><td>Rob Howard (ASG)</td><td>Peter Torr  (OSG)</td><td>Chris Mullins (ASG)</td></tr></tbody></table><div style="font-size:100%">Document editors: John Gossman (C+E), Chris Mullins (ASG), Gareth Jones (ASG), Rob Dolin (C+E), Mark Stafford (C+E)<br></div> <br><div style="font-size:100%">感谢.NET长沙社区提供的翻译，感谢译者李文强，译者周尹 <br>本文首发 .NET社区公众号，欢迎关注, 搜索 MoreDotNetCore ,里面有最新的原创性资讯，获得第一手的资料。</div><h1 id="Microsoft-REST-API指南-1"><a href="#Microsoft-REST-API指南-1" class="headerlink" title="Microsoft REST API指南"></a>Microsoft REST API指南</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Microsoft REST API指南作为一种设计原则，鼓励应用程序开发人员通过RESTful HTTP接口访问资源。</p><p>文档原则认为REST API应该遵循一致的设计指导原则，能为开发人员提供最流畅的体验，令使用它们变得简单和直观。</p><p>本文档建立了Microsoft REST API应该遵循的指导原则，以便统一一致的开发RESTful接口。</p><h2 id="2-目录"><a href="#2-目录" class="headerlink" title="2. 目录"></a>2. 目录</h2> <!-- TOC depthFrom:2 depthTo:4 orderedList:false updateOnSave:false withLinks:true --><ul><li><a href="#microsoft-rest-api-guidelines-working-group">Microsoft REST API Guidelines Working Group</a></li><li><a href="#1-abstract">1. 摘要</a></li><li><a href="#2-table-of-contents">2. 目录</a></li><li><a href="#3-introduction">3. 介绍</a><ul><li><a href="#31-recommended-reading">3.1. 推荐阅读</a></li></ul></li><li><a href="#4-interpreting-the-guidelines">4. 解读指导</a><ul><li><a href="#41-application-of-the-guidelines">4.1. 应用指导</a></li><li><a href="#42-guidelines-for-existing-services-and-versioning-of-services">4.2. 现有服务指南和服务版本化</a></li><li><a href="#43-requirements-language">4.3. 要求的语言</a></li><li><a href="#44-license">4.4. 许可证</a></li></ul></li><li><a href="#5-taxonomy">5. 分类 </a><ul><li><a href="#51-errors">5.1. 错误</a></li><li><a href="#52-faults">5.2. 故障</a></li><li><a href="#53-latency">5.3. 潜在因素</a></li><li><a href="#54-time-to-complete">5.4. 完成时间</a></li><li><a href="#55-long-running-api-faults">5.5. 长期运行的API故障</a></li></ul></li><li><a href="#6-client-guidance">6. 客户端指导</a><ul><li><a href="#61-ignore-rule">6.1. 忽略规则</a></li><li><a href="#62-variable-order-rule">6.2. 变量排序规则</a></li><li><a href="#63-silent-fail-rule">6.3. 无声失效规则</a></li></ul></li><li><a href="#7-consistency-fundamentals">7. 一致性基础</a><ul><li><a href="#71-url-structure">7.1. 网址结构</a></li><li><a href="#72-url-length">7.2. 网址长度</a></li><li><a href="#73-canonical-identifier">7.3. 标准标识符</a></li><li><a href="#74-supported-methods">7.4. 支持方法</a><ul><li><a href="#741-post">7.4.1. POST</a></li><li><a href="#742-patch">7.4.2. PATCH</a></li><li><a href="#743-creating-resources-via-patch-upsert-semantics">7.4.3. Creating resources via PATCH (UPSERT semantics)</a></li><li><a href="#744-options-and-link-headers">7.4.4. Options and link headers</a></li></ul></li><li><a href="#75-standard-request-headers">7.5. 标准请求请求头</a></li><li><a href="#76-standard-response-headers">7.6. 响应请求头</a></li><li><a href="#77-custom-headers">7.7. 自定义请求头</a></li><li><a href="#78-specifying-headers-as-query-parameters">7.8. 指定头部为查询参数</a></li><li><a href="#79-pii-parameters">7.9. PII 参数</a></li><li><a href="#710-response-formats">7.10. 响应格式</a><ul><li><a href="#7101-clients-specified-response-format">7.10.1. Clients-specified response format</a></li><li><a href="#7102-error-condition-responses">7.10.2. Error condition responses</a></li></ul></li><li><a href="#711-http-status-codes">7.11. HTTP状态码</a></li><li><a href="#712-client-library-optional">7.12. 可选的客户端库</a></li></ul></li><li><a href="#8-cors">8. CORS 跨域</a><ul><li><a href="#81-client-guidance">8.1. 客户端指导</a><ul><li><a href="#811-avoiding-preflight">8.1.1. 预检</a></li></ul></li><li><a href="#82-service-guidance">8.2. 服务端指导</a></li></ul></li><li><a href="#9-collections">9. 集合</a><ul><li><a href="#91-item-keys">9.1. 项的key</a></li><li><a href="#92-serialization">9.2. 序列化</a></li><li><a href="#93-collection-url-patterns">9.3. 集合URL模式</a><ul><li><a href="#931-nested-collections-and-properties">9.3.1. Nested collections and properties</a></li></ul></li><li><a href="#94-big-collections">9.4. 大集合</a></li><li><a href="#95-changing-collections">9.5. 修改集合</a></li><li><a href="#96-sorting-collections">9.6. 集合排序</a><ul><li><a href="#961-interpreting-a-sorting-expression">9.6.1. Interpreting a sorting expression</a></li></ul></li><li><a href="#97-filtering">9.7. 过滤</a><ul><li><a href="#971-filter-operations">9.7.1. Filter operations</a></li><li><a href="#972-operator-examples">9.7.2. Operator examples</a></li><li><a href="#973-operator-precedence">9.7.3. Operator precedence</a></li></ul></li><li><a href="#98-pagination">9.8. 分页</a><ul><li><a href="#981-server-driven-paging">9.8.1. Server-driven paging</a></li><li><a href="#982-client-driven-paging">9.8.2. Client-driven paging</a></li><li><a href="#983-additional-considerations">9.8.3. Additional considerations</a></li></ul></li><li><a href="#99-compound-collection-operations">9.9. 复合集合操作</a></li></ul></li><li><a href="#10-delta-queries">10. 增量查询</a><ul><li><a href="#101-delta-links">10.1. 增量链接</a></li><li><a href="#102-entity-representation">10.2. 实体表示</a></li><li><a href="#103-obtaining-a-delta-link">10.3. 获得增量链接</a></li><li><a href="#104-contents-of-a-delta-link-response">10.4. 增量链接响应内容</a></li><li><a href="#105-using-a-delta-link">10.5. 使用增量链接</a></li></ul></li><li><a href="#11-json-standardizations">11. JSON标准化</a><ul><li><a href="#111-json-formatting-standardization-for-primitive-types">11.1. 主要类型的JSON格式化标准化</a></li><li><a href="#112-guidelines-for-dates-and-times">11.2. 日期和时间指南</a><ul><li><a href="#1121-producing-dates">11.2.1. Producing dates</a></li><li><a href="#1122-consuming-dates">11.2.2. Consuming dates</a></li><li><a href="#1123-compatibility">11.2.3. Compatibility</a></li></ul></li><li><a href="#113-json-serialization-of-dates-and-times">11.3. 日期和时间的JSON序列化</a><ul><li><a href="#1131-the-dateliteral-format">11.3.1. The <code>DateLiteral</code> format</a></li><li><a href="#1132-commentary-on-date-formatting">11.3.2. Commentary on date formatting</a></li></ul></li><li><a href="#114-durations">11.4. 持续时间</a></li><li><a href="#115-intervals">11.5. 间隔</a></li><li><a href="#116-repeating-intervals">11.6. 重复间隔</a></li></ul></li><li><a href="#12-versioning">12. 版本</a><ul><li><a href="#121-versioning-formats">12.1. 版本格式</a><ul><li><a href="#1211-group-versioning">12.1.1. Group versioning</a></li></ul></li><li><a href="#122-when-to-version">12.2. 版本的时间</a></li><li><a href="#123-definition-of-a-breaking-change">12.3. 非延续性更改的定义</a></li></ul></li><li><a href="#13-long-running-operations">13. 长时间运行的操作</a><ul><li><a href="#131-resource-based-long-running-operations-relo">13.1. 基于资源的长时间运行(RELO)</a></li><li><a href="#132-stepwise-long-running-operations">13.2. 分步运行的长时间操作</a><ul><li><a href="#1321-put">13.2.1. PUT</a></li><li><a href="#1322-post">13.2.2. POST</a></li><li><a href="#1323-post-hybrid-model">13.2.3. POST, hybrid model</a></li><li><a href="#1324-operations-resource">13.2.4. Operations resource</a></li><li><a href="#1325-operation-resource">13.2.5. Operation resource</a></li><li><a href="#1326-operation-tombstones">13.2.6. Operation tombstones</a></li><li><a href="#1327-the-typical-flow-polling">13.2.7. The typical flow, polling</a></li><li><a href="#1328-the-typical-flow-push-notifications">13.2.8. The typical flow, push notifications</a></li><li><a href="#1329-retry-after">13.2.9. Retry-After</a></li></ul></li><li><a href="#133-retention-policy-for-operation-results">13.3. 操作结果保留策略</a></li></ul></li><li><a href="#14-throttling-quotas-and-limits">14. Throttling, Quotas, and Limits</a><ul><li><a href="#141-principles">14.1. Principles</a></li><li><a href="#142-return-codes-429-vs-503">14.2. Return Codes (429 vs 503)</a></li><li><a href="#143-retry-after-and-ratelimit-headers">14.3. Retry-After and RateLimit Headers</a></li><li><a href="#144-service-guidance">14.4. Service Guidance</a><ul><li><a href="#1441-responsiveness">14.4.1. Responsiveness</a></li><li><a href="#1442-rate-limits-and-quotas">14.4.2. Rate Limits and Quotas</a></li><li><a href="#1443-overloaded-services">14.4.3. Overloaded services</a></li><li><a href="#1444-example-response">14.4.4. Example Response</a></li></ul></li><li><a href="#145-caller-guidance">14.5. Caller Guidance</a></li><li><a href="#146-handling-callers-that-ignore-retry-after-headers">14.6. Handling callers that ignore Retry-After headers</a></li></ul></li><li><a href="#15-push-notifications-via-webhooks">15. 通过webhooks推送通知</a><ul><li><a href="#151-scope">15.1. 范围</a></li><li><a href="#152-principles">15.2. 原则</a></li><li><a href="#153-types-of-subscriptions">15.3. 订阅类型</a></li><li><a href="#154-call-sequences">15.4. 调用序列</a></li><li><a href="#155-verifying-subscriptions">15.5. 验证订阅</a></li><li><a href="#156-receiving-notifications">15.6. 接收通知</a><ul><li><a href="#1561-notification-payload">15.6.1. Notification payload</a></li></ul></li><li><a href="#157-managing-subscriptions-programmatically">15.7. programmatically订阅管理</a><ul><li><a href="#1571-creating-subscriptions">15.7.1. Creating subscriptions</a></li><li><a href="#1572-updating-subscriptions">15.7.2. Updating subscriptions</a></li><li><a href="#1573-deleting-subscriptions">15.7.3. Deleting subscriptions</a></li><li><a href="#1574-enumerating-subscriptions">15.7.4. Enumerating subscriptions</a></li></ul></li><li><a href="#158-security">15.8. 安全性</a></li></ul></li><li><a href="#16-unsupported-requests">16. 不支持的请求</a><ul><li><a href="#161-essential-guidance">16.1. 基本指导</a></li><li><a href="#162-feature-allow-list">16.2. 特征允许列表</a><ul><li><a href="#1621-error-response">16.2.1. Error response</a></li></ul></li></ul></li><li><a href="#17-naming-guidelines">17. 命名准则</a><ul><li><a href="#171-approach">17.1. 途径</a></li><li><a href="#172-casing">17.2. 框架</a></li><li><a href="#173-names-to-avoid">17.3. 避免的命名</a></li><li><a href="#174-forming-compound-names">17.4. 规范的复合词</a></li><li><a href="#175-identity-properties">17.5. 标识属性</a></li><li><a href="#176-date-and-time-properties">17.6. 日期和时间属性</a></li><li><a href="#177-name-properties">17.7. 属性名</a></li><li><a href="#178-collections-and-counts">17.8. 集合和计数</a></li><li><a href="#179-common-property-names">17.9. 共同属性命名</a></li></ul></li><li><a href="#18-appendix">18. 附录</a><ul><li><a href="#181-sequence-diagram-notes">18.1. 时序图注释</a><ul><li><a href="#1811-push-notifications-per-user-flow">18.1.1. Push notifications, per user flow</a></li><li><a href="#1812-push-notifications-firehose-flow">18.1.2. Push notifications, firehose flow</a></li></ul></li></ul></li></ul><!-- /TOC --><h2 id="3-引言"><a href="#3-引言" class="headerlink" title="3. 引言"></a>3. 引言</h2><p>开发人员通常通过HTTP接口访问大多数微软云平台资源。虽然每个服务通常提供特定于语言框架来包装其API，但它们的所有操作最终都归结为HTTP请求。微软必须支持广泛的客户端和服务，不能依赖于每个开发环境都有丰富的框架。因此，本指导原则的目标是确保Microsoft REST API能够被任何具有基本HTTP支持的客户端轻松且一致地使用。<br>[*]译者注：本指南不限于微软技术和平台，广泛适应于各种语言和平台。</p><p>为了给开发人员提供最流畅的体验，让这些API遵循统一的设计准则是很重要的，从而使其简单易用，符合人们的直觉反应。本文档建立了 Microsoft REST API 开发人员应该遵循的指南, 以便统一一致地开发API。</p><p>一致性的好处在于可以不断地积累合理的规范;一致性使团队拥有统一的代码、模式、文档风格和设计策略。</p><p>这些准则旨在达成如下目标：</p><ul><li>为Microsoft技术平台所有API端点定义一致的实现和体验。</li><li>尽可能地遵循行业普遍接受的 REST/HTTP 最佳实践。</li><li>让所有应用开发者都可以轻松的通过REST接口访问Micosoft服务。</li><li>允许Service开发者利用其他Service的基础上来开发一致的REST API端点。</li><li>允许合作伙伴(例如,非Micosoft团队)使用这些准则来设计自己的 REST API。<br>[*]注：本指南旨在构建符合 REST 架构风格的服务，但不涉及或要求构建遵循 REST 约束的服务。<br>本文档中使用的“REST”术语代指具有 RESTful风格的服务，而不是仅仅遵循 REST。</li></ul><h3 id="3-1-推荐阅读"><a href="#3-1-推荐阅读" class="headerlink" title="3.1 推荐阅读"></a>3.1 推荐阅读</h3><p>了解REST架构风格背后的理念，更有助于开发优秀的基于 HTTP 的服务。<br>如果您对 RESTful 设计不熟悉，请参阅以下优秀资源：</p><ul><li>REST on Wikipedia — 维基百科上关于REST的核心概念与思想的介绍。</li><li>REST论文—— Roy Fielding网络架构论文中关于REST的章节，“架构风格与基于网络的软件体系结构设计”</li><li>RFC 7231—— 定义HTTP/1.1 语义规范的权威资源。</li><li>REST 实践—— 关于REST的基础知识的入门书。</li></ul><p>[*]译者注：上一篇说了，REST 指的是一组架构约束条件和原则。那么满足这些约束条件和原则的应用程序或设计就是 RESTful。</p><h2 id="4-解读指导"><a href="#4-解读指导" class="headerlink" title="4. 解读指导"></a>4. 解读指导</h2><h3 id="4-1-应用指南"><a href="#4-1-应用指南" class="headerlink" title="4.1 应用指南"></a>4.1 应用指南</h3><p>这些准则适用于Microsoft或任何合作伙伴服务公开的任何REST API。私有或内部API也应该尝试遵循这些准则，因为内部服务最终可能会被公开。保证一致性不仅对外部客户有价值，对内部服务使用者也很有价值，而这些准则为对任何服务都提供了最佳实践。<br>有合理理由可不遵循这些准则。如：实现或必须与某些外部定义的REST API互操作的REST服务必须与哪些外部的API兼容，而无法遵循这些准则。而还有一些服务也可能具有需要特殊性能需求，必须采用其他格式，例如二进制协议。</p><h3 id="4-2-现有服务和服务版本控制的指南"><a href="#4-2-现有服务和服务版本控制的指南" class="headerlink" title="4.2 现有服务和服务版本控制的指南"></a>4.2 现有服务和服务版本控制的指南</h3><p>我们不建议仅仅为了遵从指南而对这些指南之前的旧服务进行重大更改。无论如何，当兼容性被破坏时，该服务应该尝试在下一版本发布时变得合规。<br>当一个服务添加一个新的API时，该API应该与同一版本的其他API保持一致。<br>因此，如果服务是针对 1.0 版本的指南编写的，那么增量添加到服务的新 API 也应该遵循 1.0 版本指南。然后该服务在下一次主要版本更新时，再去遵循最新版指南。 </p><h3 id="4-3-要求语言"><a href="#4-3-要求语言" class="headerlink" title="4.3 要求语言"></a>4.3 要求语言</h3><p>本文档中的”MUST”（必须）, “MUST NOT”（禁止）, “REQUIRED”（需要）, “SHALL”（将要）, “SHALL NOT”（最好不要）, “SHOULD”（应该）, “SHOULD NOT”（不应该）, “RECOMMENDED”（推荐）, “MAY”（可能）, 和 “OPTIONAL”（可选） 等关键字的详细解释见 RFC 2119。</p><h3 id="4-4-许可证"><a href="#4-4-许可证" class="headerlink" title="4.4 许可证"></a>4.4 许可证</h3><p>本作品根据知识共享署名4.0国际许可协议授权。如需查看本授权的副本，请访问<a href="http://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">http://creativecommons.org/licenses/by/4.0/</a> 或致函  PO Box 1866, Mountain View, CA 94042, USA.</p><p>[*]译者注：署名 4.0 国际，也就是允许在任何媒介以任何形式复制、发行本作品，允许修改、转换或以本作品为基础进行创作。允许任何用途，甚至商业目的。</p><h2 id="5-分类"><a href="#5-分类" class="headerlink" title="5. 分类"></a>5. 分类</h2><p>作为Microsoft REST API指南的一部分，服务必须符合下面定义的分类法。</p><h3 id="5-1-错误"><a href="#5-1-错误" class="headerlink" title="5.1 错误"></a>5.1 错误</h3><p>错误，或者更具体地说是服务错误，定义为因客户端向服务传递错误数据，导致服务端拒绝该请求。示例包括无效凭证、错误的参数、未知的版本ID等。客户端传递错误的或者不合法的数据的情况通常返回 “4XX” 的 HTTP 错误代码。</p><p>错误不会影响API的整体可用性。</p><p>[*]译者注：错误可以理解成客户端参数错误，通常返回“4XX”状态码，并不影响整体的API使用。</p><h3 id="5-2-故障"><a href="#5-2-故障" class="headerlink" title="5.2 故障"></a>5.2 故障</h3><p>故障（缺陷），或者更具体地说是服务故障，定义为服务无法正确返回数据以响应有效的客户端请求。通常会返回“5xx”HTTP错误代码。</p><p>故障会影响整体 API 的可用性。<br>由于速率限制（限流）或配额故障而失败的调用不能算作故障。由于服务快速失败(fast-failing)请求(通常是为了保护自己)而失败的调用会被视为故障。</p><p>[*]译者注：故障意味着服务端代码出现故障，可能会影响整体的API使用。比如数据库连接超时。<br>fast-failing 快速失败<br>safe-failing 安全失败</p><h3 id="5-3-延迟"><a href="#5-3-延迟" class="headerlink" title="5.3 延迟"></a>5.3 延迟</h3><p>延迟定义为特定的API调用完成所需的时间(尽可能使用客户端调用进行测量)。此测量方法同样适用于同步和异步的API。对于长时间运行(long running calls)的调用，延迟定义为第一次调用它所需的时长，而不是整个操作)完成所需的时间。</p><p>[*]译者注：Latency（延迟）是衡量软件系统的最常见的指标之一，不仅仅和系统、架构的性能相关，还和网络传输和延迟有关系。</p><h3 id="5-4-完成时间"><a href="#5-4-完成时间" class="headerlink" title="5.4 完成时间"></a>5.4 完成时间</h3><p>暴露长时间操作的服务必须跟踪这些操作的 “完成时间” 指标。</p><h3 id="5-5-长期运行API故障"><a href="#5-5-长期运行API故障" class="headerlink" title="5.5 长期运行API故障"></a>5.5 长期运行API故障</h3><p>对于长期运行的 API，很可能出现第一次请求成功，且后续每次去获取结果时 API 也处于正常运行（每次都回传 200）中，但其底层操作已经失败了的情况。长期运行故障必须作为故障汇总到总体可用性指标中。</p><h2 id="6-客户端指导"><a href="#6-客户端指导" class="headerlink" title="6. 客户端指导"></a>6. 客户端指导</h2><p>为确保客户端更好的接入REST服务，客户端应遵循以下最佳实践:</p><h3 id="6-1-忽略规则"><a href="#6-1-忽略规则" class="headerlink" title="6.1 忽略规则"></a>6.1 忽略规则</h3><p>对于松散耦合的客户端调用，在调用之前不知道数据的确切定义和格式，如果服务器没用返回客户端预期的内容，客户端必须安全地忽略它。</p><p>在服务迭代的过程中，有些服务（接口）可能在不更改版本号的情况下向响应添加字段。此类服务必须在其文档中注明，客户端必须忽略这些未知字段。</p><p>[*]译者注：一个已发布的在线接口服务，如果不修改版本而增加字段，那么一定不能影响已有的客户端调用。</p><h3 id="6-2-变量排序规则"><a href="#6-2-变量排序规则" class="headerlink" title="6.2 变量排序规则"></a>6.2 变量排序规则</h3><p>客户端处理响应数据时一定不能依赖服务端JSON响应数据字段的顺序。例如，例如，当服务器返回的 JSON 对象中的字段顺序发生变化，客户端应当能够正确进行解析处理。<br>当服务端支持时，客户端可以请求以特定的顺序返回数据。例如，服务端可能支持使用$orderBy querystring参数来指定JSON数组中元素的顺序。<br>服务端也可以在协议中显式说明指定某些元素按特定方式进行排序。例如，服务端可以每次返回 JSON 对象时都把 JSON 对象的类型信息作为第一个字段返回，进而简化客户端解析返回数据格式的难度。客户端处理数据时可以依赖于服务端明确指定了的排序行为。</p><h3 id="6-3-无声失效规则"><a href="#6-3-无声失效规则" class="headerlink" title="6.3 无声失效规则"></a>6.3 无声失效规则</h3><p>当客户端请求带可选功能参数的服务时（例如带可选的头部信息），必须对服务端的返回格式有一定兼容性，可以忽略某些特定功能。</p><p>[*]译者注：例如分页数、排序等自定义参数的支持和返回格式的兼容。</p><h2 id="7-基础原则"><a href="#7-基础原则" class="headerlink" title="7. 基础原则"></a>7. 基础原则</h2><h3 id="7-1-URL结构"><a href="#7-1-URL结构" class="headerlink" title="7.1 URL结构"></a>7.1 URL结构</h3><p>URL必须保证友好的可读性与可构造性，人类应该能够轻松地读取和构造url。:)<br>这有助于用户发现并简化接口的调用，即使平台没有良好的客户端SDK支持。<br>[*]译者注：API URL路径结构应该是友好的易于理解的。甚至用户无需通过阅读API文档能够猜出相关结构和路径。</p><p>结构良好的URL的一个例子是:<br><a href="https://api.contoso.com/v1.0/people/jdoe@contoso.com/inbox" target="_blank" rel="noopener">https://api.contoso.com/v1.0/people/jdoe@contoso.com/inbox</a><br>[*]译者注：通过以上URL我们可以获知API的版本、people资源、用户标识（邮箱）、收件箱，而且很容易获知——这是jdoe的收件箱的API。</p><p>一个不友好的示例URL是:<br><a href="https://api.contoso.com/EWS/OData/Users(&#39;jdoe@microsoft.com&#39;)/Folders(&#39;AAMkADdiYzI1MjUzLTk4MjQtNDQ1Yy05YjJkLWNlMzMzYmIzNTY0MwAuAAAAAACzMsPHYH6HQoSwfdpDx-2bAQCXhUk6PC1dS7AERFluCgBfAAABo58UAAA=&#39;)" target="_blank" rel="noopener">https://api.contoso.com/EWS/OData/Users(&#39;jdoe@microsoft.com&#39;)/Folders(&#39;AAMkADdiYzI1MjUzLTk4MjQtNDQ1Yy05YjJkLWNlMzMzYmIzNTY0MwAuAAAAAACzMsPHYH6HQoSwfdpDx-2bAQCXhUk6PC1dS7AERFluCgBfAAABo58UAAA=&#39;)</a><br>[*]译者注：这是ODATA的API，不过目录标识不易于理解，没什么意义。</p><p>出现的常见模式是使用URL作为值（参数）。服务可以使用URL作为值。<br>例如，以下内容是可以接受的(URL中，url参数传递了花式的鞋子这个资源):<br><a href="https://api.contoso.com/v1.0/items?url=https://resources.contoso.com/shoes/fancy" target="_blank" rel="noopener">https://api.contoso.com/v1.0/items?url=https://resources.contoso.com/shoes/fancy</a><br>[*]译者注：Token第三方认证中把登陆前来源地址返回给客户端。</p><h3 id="7-2-URL长度"><a href="#7-2-URL长度" class="headerlink" title="7.2 URL长度"></a>7.2 URL长度</h3><p>HTTP 1.1消息格式(在第3.1.1节的RFC 7230中定义)对请求没有长度限制，其中包括目标URL。RFC的:</p><blockquote><p>HTTP没有对请求行长度设置预定义的限制。[…如果服务器接收到的请求目标比它希望解析的任何URI都长，那么它必须使用 414 (URI太长)状态代码进行响应。</p></blockquote><p>服务如果能够生成超过2,083个字符的url，必须考虑兼容它支持的客户端。不同客户端支持的最长 URL 长度参见以下资料：</p><ul><li><a href="http://stackoverflow.com/a/417184" target="_blank" rel="noopener">http://stackoverflow.com/a/417184</a></li><li><a href="https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/</a></li></ul><p>还请注意，一些技术栈有强制的的URL限定，所以在设计服务时要记住这一点。</p><h3 id="7-3-规范标识符"><a href="#7-3-规范标识符" class="headerlink" title="7.3 规范标识符"></a>7.3 规范标识符</h3><p>除了提供友好的URL之外，能够移动或重命名的资源必须包含唯一稳定的标识符。<br>在与 服务 进行交互时可能需要通过友好的名称来获取资源固定的 URL，就像某些服务使用的“/my”快捷方式一样。<br>指南不强制要求 固定标识符使用GUID。<br>包含规范标识符的URL的一个例子是（标识符比较友好):<br>  <a href="https://api.contoso.com/v1.0/people/7011042402/inbox" target="_blank" rel="noopener">https://api.contoso.com/v1.0/people/7011042402/inbox</a></p><p>[<em>]译者注：一般是暴露主键字段，也可以是其他唯一的易于理解的字段，比如姓名、标题、邮箱等等。<br>[</em>]译者注：GUID太长而且不易于理解和阅读，如果不是必须，尽量少用此字段。</p><h3 id="7-4-支持方法"><a href="#7-4-支持方法" class="headerlink" title="7.4 支持方法"></a>7.4 支持方法</h3><p>客户端必须尽可能使用正确的HTTP动词来执行操作，并且必须考虑是否支持此操作的幂等性。HTTP方法通常称为HTTP动词。</p><p>在此上下文中，术语是同义词，但是HTTP规范使用术语方法。</p><p>下面是Microsoft REST服务应该支持的方法列表。并不是所有资源都支持所有方法，但是使用以下方法的所有资源必须符合它们的用法。</p><p>| Method  |  Description | Is Idempotent<br>|:–|:–|<br>| GET | 返回对象的当前值 | True<br>| PUT | 在适用时替换对象，或创建命名对象 | True<br>| DELETE | 删除对象 | True<br>| POST | 根据提供的数据创建一个新对象，或者提交一个操作 | False<br>| HEAD | 返回GET响应的对象的元数据。支持GET方法的资源也可能支持HEAD方法 | True<br>| PATCH | 更新对象部分应用 | False<br>| OPTIONS | 获取关于请求的信息;详见下文。 | True</p><h4 id="7-4-1-POST"><a href="#7-4-1-POST" class="headerlink" title="7.4.1  POST"></a>7.4.1  POST</h4><p>POST操作应该支持重定向响应标头（Location），以便通过重定向标头返回创建好的资源的链接。</p><p>例如，假设一个服务允许创建并命名托管服务器:</p><blockquote><p>POST <a href="http://api.contoso.com/account1/servers" target="_blank" rel="noopener">http://api.contoso.com/account1/servers</a><br>响应应该是这样的:</p></blockquote><blockquote><p>201 Created<br>Location:<a href="http://api.contoso.com/account1/servers/server321" target="_blank" rel="noopener">http://api.contoso.com/account1/servers/server321</a></p></blockquote><p>其中“server321”是服务分配的服务器名。</p><p>服务还可以在响应中返回已创建项的完整元数据。</p><h4 id="7-4-2-PATCH"><a href="#7-4-2-PATCH" class="headerlink" title="7.4.2. PATCH"></a>7.4.2. PATCH</h4><p>PATCH已被IETF标准化为用于增量更新现有对象的方法（参见RFC 5789）。符合Microsoft REST API准则的API应该支持PATCH。</p><h4 id="7-4-3-Creating-resources-via-PATCH-UPSERT-semantics-通过-PATCH-创建资源（UPSERT-定义）"><a href="#7-4-3-Creating-resources-via-PATCH-UPSERT-semantics-通过-PATCH-创建资源（UPSERT-定义）" class="headerlink" title="7.4.3. Creating resources via PATCH (UPSERT semantics) 通过 PATCH 创建资源（UPSERT 定义）"></a>7.4.3. Creating resources via PATCH (UPSERT semantics) 通过 PATCH 创建资源（UPSERT 定义）</h4><p>允许客户端在创建资源的时候只指定部分键值（key）数据的必须支持UPSET语义，该服务必须支持以PATCH动词来创建资源。</p><p>鉴于PUT被定义为内容的完全替换，所以客户端使用PUT修改数据是危险的。</p><p>当试图更新资源时，不理解(并因此忽略)资源的某些属性的客户端，很可能在PUT上忽视这些属性，导致提交后这些属性可能在不经意间被删除。</p><p>所以，如果选择支持PUT来更新现有资源，则必须是完整替换(即，PUT之后，资源的属性必须匹配请求中提供的内容，包括删除没有提供的任何服务端的属性)。</p><p>在UPSERT语义下，对不存在资源的 PATCH 调用，由服务器作为“创建”处理，对已存在的资源的 PATCH 调用作为“更新”处理。<br>为了确保更新请求不被视为创建（反之亦然），客户端可以在请求中指定预先定义的 HTTP 请求头。</p><ul><li>如果 PATCH 请求包含if-match标头，则服务不能将其视为插入;如果 PATCH 请求包含值为 “*” 的if-none-match头，则服务不能将其视为更新。</li></ul><p>如果服务不支持UPSERT，则针对不存在的资源的 PATCH 调用必须导致 HTTP “409 Conflict”错误。</p><h4 id="7-4-4-Options-标头-和-link-headers-标签"><a href="#7-4-4-Options-标头-和-link-headers-标签" class="headerlink" title="7.4.4  Options 标头 和 link headers 标签"></a>7.4.4  Options 标头 和 link headers 标签</h4><p>OPTIONS 允许客户端查询某个资源的元信息，并至少可以通过返回支持该资源的有效方法（支持的动词类别）的Allow 标头。<br>[*]译者注：当发起跨域请求时，浏览器会自动发起OPTIONS请求进行检查。</p><p>此外，建议服务返回应该包括一个指向有关资源的稳定链接（Link header）(见RFC 5988):</p><pre class=" language-http"><code class="language-http"><span class="token header-name keyword">Link:</span> &lt;{help}>; rel="help"</code></pre><p>其中{help}是指向文档资源的URL。</p><p>有关选项使用的示例，请参见完善CORS跨域调用。</p><h3 id="7-5-标准的请求标头"><a href="#7-5-标准的请求标头" class="headerlink" title="7.5 标准的请求标头"></a>7.5 标准的请求标头</h3><p>下面的请求标头表 应该遵循 Microsoft REST API指南服务使用。使用这些标题不是强制性的，但如果使用它们则必须始终一致地使用。</p><p>所有标头值都必须遵循规范中规定的标头字段所规定的语法规则。许多HTTP标头在RFC7231中定义，但是在IANA标头注册表中可以找到完整的已批准头列表。</p><table><thead><tr><th align="left">Header 标头</th><th align="left">Type 类型</th><th align="left">Description 描述</th></tr></thead><tbody><tr><td align="left">Authorization</td><td align="left">String</td><td align="left">请求的授权标头</td></tr><tr><td align="left">Date</td><td align="left">Date</td><td align="left">请求的时间戳，基于客户端的时钟，采用RFC 5322日期和时间格式。服务器不应该对客户端时钟的准确性做任何假设。此标头可以包含在请求中，但在提供时必须采用此格式。当提供此报头时，必须使用格林尼治平均时间(GMT)作为时区参考。例如：Wed, 24 Aug 2016 18:41:30 GMT. 请注意，GMT正好等于UTC（协调世界时）。</td></tr><tr><td align="left">Accept</td><td align="left">Content type</td><td align="left">响应请求的内容类型，如:</td></tr><tr><td align="left">- application/xml</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">- text/xml</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">- application/json</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">- text/javascript (for JSONP)</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">根据HTTP准则，这只是一个提示，响应可能有不同的内容类型，例如blob fetch，其中成功的响应将只是blob流作为有效负载。对于遵循OData的服务，应该遵循OData中指定的首选项顺序。</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">Accept-Encoding</td><td align="left">Gzip, deflate</td><td align="left">如果适用，REST端点应该支持GZIP和DEFLATE编码。对于非常大的资源，服务可能会忽略并返回未压缩的数据。</td></tr><tr><td align="left">Accept-Language</td><td align="left">“en”, “es”, etc.</td><td align="left">指定响应的首选语言。不需要服务来支持这一点，但是如果一个服务支持本地化，那么它必须通过Accept-Language头来支持本地化。</td></tr><tr><td align="left">Accept-Charset</td><td align="left">Charset type like “UTF-8”</td><td align="left"></td></tr><tr><td align="left">默认值是UTF-8，但服务应该能够处理ISO-8859-1</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">Content-Type</td><td align="left">Content type</td><td align="left">Mime type of request body (PUT/POST/PATCH)</td></tr><tr><td align="left">Prefer</td><td align="left">return=minimal, return=representation</td><td align="left">如果指定了return = minimal首选项，则服务应该返回一个空主体（empty body）以响应一次成功插入或更新。如果指定了return = representation，则服务应该在响应中返回创建或更新的资源。如果服务的场景中客户端有时会从响应中获益，但有时响应会对带宽造成太大的影响，那么它们应该支持这个报头。</td></tr><tr><td align="left">If-Match, If-None-Match, If-Range</td><td align="left">String</td><td align="left">使用乐观并发控制支持资源更新的服务必须支持If-Match标头。服务也可以使用其他与ETag相关的头，只要它们遵循HTTP规范。</td></tr></tbody></table><h2 id="7-6-标准响应标头"><a href="#7-6-标准响应标头" class="headerlink" title="7.6 标准响应标头"></a>7.6 标准响应标头</h2><p>服务应该返回以下响应标头，除非在“required”列中注明。</p><p>| Response Header | Required | Description |<br>| 响应报头 | 必填 | 描述 |<br>|:–|:–|:–|<br>| Date | All responses | 根据服务器的时钟，以RFC 5322日期和时间格式处理响应。这个头必须包含在响应中。此报头必须使用格林尼治平均时间(GMT)作为时区参考。例如:Wed, 24 Aug 2016 18:41:30 GMT.请注意，GMT正好等于协调世界时(UTC)。 |<br>| Content-Type |  All responses| 内容类型 |<br>| Content-Encoding | All responses | GZIP或DEFLATE，视情况而定 |<br>| Preference-Applied | 在请求中指定时 | 是否应用了首选项请求头中指示的首选项 |<br>| ETag | 当请求的资源具有实体标记时 | ETag响应头字段为请求的变量提供实体标记的当前值。与If-Match、If-None-Match和If-Range一起使用，实现乐观并发控制。 | </p><h2 id="7-7-自定义标头"><a href="#7-7-自定义标头" class="headerlink" title="7.7. 自定义标头"></a>7.7. 自定义标头</h2><p>基本的API操作不应该支持自定义标头。</p><p>本文档中的一些准则规定了非标准HTTP标头的使用。此外，某些服务可能需要添加额外的功能，这些功能通过HTTP标头文件公开。以下准则有助于在使用自定义标头时保持一致性。</p><p>非标准HTTP标头必须具有以下两种格式之一:</p><ol><li>使用IANA（RFC 3864）注册为“临时”的标头的通用格式</li><li>为注册使用过特定的头文件的范围格式<br>这两种格式如下所述。</li></ol><h2 id="7-8-以查询参数方式提交自定义请求头"><a href="#7-8-以查询参数方式提交自定义请求头" class="headerlink" title="7.8. 以查询参数方式提交自定义请求头"></a>7.8. 以查询参数方式提交自定义请求头</h2><p>有些标头对某些场景(如AJAX客户端)不兼容，特别是在不支持添加标头的跨域调用时。因此，除了常见的标头信息外，一些标头信息可以允许被作为查询参数传递给服务端，其命名与请求头中的名称保持一致:</p><p>并不是所有的标头都可以用作查询参数，包括大多数标准HTTP标头。<br>考虑何时接受标头作为参数的标准如下:</p><ol><li>任何自定义标头也必须作为参数接受。</li><li>请求的标准标头也可以作为参数接受。 </li><li>具有安全敏感性的必需标头(例如，授权标头 Authorization)可能不适合作为参数;服务所有者应该具体情况具体分析。</li></ol><p>此规则的一个例外是Accept头。使用具有简单名称的方案，而不是使用HTTP规范中描述的用于Accept的完整功能，这是一种常见的实践。</p><h2 id="7-9-PII-个人身份信息参数"><a href="#7-9-PII-个人身份信息参数" class="headerlink" title="7.9. PII 个人身份信息参数"></a>7.9. PII 个人身份信息参数</h2><p>与普遍的隐私政策一致，客户端不应该在URL中传输个人身份信息(PII)参数(作为路径或查询参数)，因为这些信息可能通过客户端、网络和服务器日志和其他机制无意暴露出来。</p><p>因此，服务应该接受PII参数作为标头传输。</p><p>然而在实践中，由于客户端或软件的限制，在许多情况下无法遵循上述建议。为了解决这些限制，服务也应该接受这些PII参数作为URL的一部分，与本指导原则的其余部分保持一致。</p><p>接受PII参数(无论是在URL中还是作为标头)的服务 应该符合其组织的隐私保护原则。通常建议包括：客户端使用标头进行加密传输，并且实现要遵循特殊的预防措施，以确保日志和其他服务数据收集得到正确的处理。</p><p>[*]译者注：PII——个人可标识信息。比如家庭地址，身份证信息。</p><h2 id="7-10-Response-formats-响应格式"><a href="#7-10-Response-formats-响应格式" class="headerlink" title="7.10. Response formats 响应格式"></a>7.10. Response formats 响应格式</h2><p>一个成功的平台，往往提供可读性较好并且一致的响应结果，并允许开发人员使用公共 Http 代码处理响应。</p><p>基于Web的通信，特别是当涉及移动端或其他低带宽客户端时，我们推荐使用JSON作为传输格式。主要是由于其更轻量以及易于与JavaScript交互。</p><p>JSON属性名应该采用camelCasedE驼峰命名规范。</p><p>服务应该提供JSON作为默认输出格式。</p><h3 id="7-10-1-Clients-specified-客户端指定响应格式"><a href="#7-10-1-Clients-specified-客户端指定响应格式" class="headerlink" title="7.10.1 Clients-specified 客户端指定响应格式"></a>7.10.1 Clients-specified 客户端指定响应格式</h3><p>在HTTP中，客户端应该使用Accept头请求响应格式。 服务端可以选择性的忽略，如客户端发送多个Accept标头，服务可以选择其中一个格式进行响应。</p><p>默认的响应格式(没有提供Accept头)应该是application/json，并且所有服务必须支持application/json。</p><p>| Accept Header | Response type | Notes |<br>| 接受标头 | 响应类型 | 备注 |<br>|:–|:–|:–|<br>| application/json     | 必须是返回json格式 | 同样接受JSONP请求的text/JavaScript |</p><pre class=" language-GET"><code class="language-GET">Accept: application/json</code></pre><h3 id="7-10-2-错误的条件响应"><a href="#7-10-2-错误的条件响应" class="headerlink" title="7.10.2 错误的条件响应"></a>7.10.2 错误的条件响应</h3><p>对于调用不成功的情况，开发人员应该能够用相同的代码库一致地处理错误。这允许构建简单可靠的基础架构来处理异常，将异常作为成功响应的独立处理流程来处理。下面的代码基于OData v4 JSON规范。但是，它非常通用，不需要特定的OData构造。即使api没有使用其他OData结构，也应该使用这种格式。</p><p>错误响应必须是单个JSON对象。该对象必须有一个名为“error”的 名称/值（name/value） 对。该值必须是JSON对象。</p><p>这个对象必须包含名称“code”和“message”的 键值对，并且它建议包含譬如“target”、“details”和 “innererror” 的键值对。</p><p>“code”键值对的值 是一个与语言无关的字符串。它的值是该服端务定义的错误代码，应该简单可读。与响应中指定的HTTP错误代码相比，此代码用作错误的更具体的指示。服务应该具有相对较少的“code”数量(别超过20个)，并且所有客户端必须能够处理所有这些错误信息。<br>大多数服务将需要更大数量的更具体的错误代码以满足所有的客户端请求。这些错误代码应该在“innererror” 键值对中公开，如下所述。为现有客户端可见的“代码”引入新值是一个破坏性的更改，需要增加版本。服务可以通过向“innererror”添加新的错误代码来避免中断服务更改。</p><p>“message”键值对的值 必须是错误提示消息，必须是可读且易于理解。它旨在是帮助开发人员，不适合暴露给最终用户。想要为最终用户公开合适消息的服务必须通过annotation注释或其他自定义属性来公开。服务不应该为最终用户本地化“message”，因为这样对于开发者变得非常不友好并且难以处理。</p><p>“target”键值对的值 是指向错误的具体的目标(例如，错误中属性的名称)。</p><p>“details”键值对的值 必须是JSON对象数组，其中必须包含“code”和“message”的键值对，还可能包含“target”的键值对，如上所述。“details”数组中的对象通常表示请求期间发生的不同的、相关的错误。请参见下面的例子。</p><p>“innererror”键值对的值 必须是一个对象。这个对象的内容是服务端定义的。想要返回比根级别代码更具体的错误的服务，必须包含“code”的键值对和嵌套的“innererror”。每个嵌套的“innererror”对象表示比其父对象更高层次的细节。在评估错误时，客户端必须遍历所有嵌套的“内部错误”，并选择他们能够理解的最深的一个。这个方案允许服务在层次结构的任何地方引入新的错误代码，而不破坏向后兼容性，只要旧的错误代码仍然出现。服务可以向不同的调用者返回不同级别的深度和细节。例如，在开发环境中，最深的“innererror”可能包含有助于调试服务的内部信息。为了防范信息公开带来的潜在安全问题，服务应注意不要无意中暴露过多的细节。错误对象还可以包括特定于代码的自定义服务器定义的键值对。带有自定义服务器定义属性的错误类型应该在服务的元数据文档中声明。请参见下面的例子。</p><p>错误响应返回的的任何JSON对象中都可能包含注释。</p><p>我们建议，对于任何可能重试的临时错误，服务应该包含一个  Retry-After  HTTP头，告诉客户端在再次尝试操作之前应该等待的最小秒数。</p><h5 id="ErrorResponse-Object"><a href="#ErrorResponse-Object" class="headerlink" title="ErrorResponse : Object"></a>ErrorResponse : Object</h5><table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody><tr><td><code>error</code></td><td>Error</td><td>✔</td><td>The error object.</td></tr></tbody></table><h5 id="Error-Object"><a href="#Error-Object" class="headerlink" title="Error : Object"></a>Error : Object</h5><table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody><tr><td><code>code</code></td><td>String (enumerated)</td><td>✔</td><td>服务器定义的错误代码集之一。<code>message</code></td></tr><tr><td><code>target</code></td><td>String</td><td></td><td>The target of the error.</td></tr><tr><td><code>details</code></td><td>Error[]</td><td></td><td>An array of details about specific errors that led to this reported error.</td></tr><tr><td><code>innererror</code></td><td>InnerError</td><td></td><td>An object containing more specific information than the current object about the error.</td></tr></tbody></table><h5 id="InnerError-Object"><a href="#InnerError-Object" class="headerlink" title="InnerError : Object"></a>InnerError : Object</h5><table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody><tr><td><code>code</code></td><td>String</td><td></td><td>A more specific error code than was provided by the containing error.</td></tr><tr><td><code>innererror</code></td><td>InnerError</td><td></td><td>An object containing more specific information than the current object about the error.</td></tr></tbody></table><h5 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h5><p>内部错误的例子:</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"error"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"code"</span><span class="token operator">:</span> <span class="token string">"BadArgument"</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Previous passwords may not be reused"</span><span class="token punctuation">,</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"password"</span><span class="token punctuation">,</span>    <span class="token property">"innererror"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"code"</span><span class="token operator">:</span> <span class="token string">"PasswordError"</span><span class="token punctuation">,</span>      <span class="token property">"innererror"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"code"</span><span class="token operator">:</span> <span class="token string">"PasswordDoesNotMeetPolicy"</span><span class="token punctuation">,</span>        <span class="token property">"minLength"</span><span class="token operator">:</span> <span class="token string">"6"</span><span class="token punctuation">,</span>        <span class="token property">"maxLength"</span><span class="token operator">:</span> <span class="token string">"64"</span><span class="token punctuation">,</span>        <span class="token property">"characterTypes"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"lowerCase"</span><span class="token punctuation">,</span><span class="token string">"upperCase"</span><span class="token punctuation">,</span><span class="token string">"number"</span><span class="token punctuation">,</span><span class="token string">"symbol"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"minDistinctCharacterTypes"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token property">"innererror"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"code"</span><span class="token operator">:</span> <span class="token string">"PasswordReuseNotAllowed"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在本例中，基本的错误代码是“BadArgument”，但是对于感兴趣的客户端，“innererror”中提供了更具体的错误代码。<br>“passwordreusenotal”代码可能是在之后的迭代中由该服务添加的，之前只返回“passwordnotmeetpolicy”。<br>这种增量型的添加方式并不会破坏老的客户端的处理过程，而又可以给开发者一些更详细的信息。<br>“PasswordDoesNotMeetPolicy”错误还包括额外的键值对，这些键值对 允许客户机确定服务器的配置、以编程方式验证用户的输入，或者在客户机自己的本地化消息传递中向用户显示服务器的约束。</p><p>详细的例子 “details”:</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"error"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"code"</span><span class="token operator">:</span> <span class="token string">"BadArgument"</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Multiple errors in ContactInfo data"</span><span class="token punctuation">,</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"ContactInfo"</span><span class="token punctuation">,</span>    <span class="token property">"details"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"code"</span><span class="token operator">:</span> <span class="token string">"NullValue"</span><span class="token punctuation">,</span>        <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"PhoneNumber"</span><span class="token punctuation">,</span>        <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Phone number must not be null"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"code"</span><span class="token operator">:</span> <span class="token string">"NullValue"</span><span class="token punctuation">,</span>        <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"LastName"</span><span class="token punctuation">,</span>        <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Last name must not be null"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"code"</span><span class="token operator">:</span> <span class="token string">"MalformedValue"</span><span class="token punctuation">,</span>        <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"Address"</span><span class="token punctuation">,</span>        <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Address is not valid"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在本例中，请求存在多处问题，每个错误都列在 “details” 字段中进行返回了。</p><h3 id="7-11-HTTP状态代码-HTTP-Status-Codes"><a href="#7-11-HTTP状态代码-HTTP-Status-Codes" class="headerlink" title="7.11 HTTP状态代码 HTTP Status Codes"></a>7.11 HTTP状态代码 HTTP Status Codes</h3><p>应使用标准HTTP状态码作为响应状态码; 更多信息，请参见HTTP状态代码定义。</p><h3 id="7-12-客户端库可选-Client-library-optional"><a href="#7-12-客户端库可选-Client-library-optional" class="headerlink" title="7.12. 客户端库可选 Client library optional"></a>7.12. 客户端库可选 Client library optional</h3><p>开发人员必须能够在各种平台和语言上进行开发，比如Windows、macOS、Linux、c#、Python和Node.js或是Ruby。</p><p>服务应该能够让简单的HTTP工具(如curl)进行访问，而不需要做太多的工作。</p><p>该服务提供给开发人员的网站应该提供相当于“获得开发者令牌(Get developer Token)的功能，以帮助开发人员测试并应提供curl支持。</p><h2 id="8-CORS-跨域"><a href="#8-CORS-跨域" class="headerlink" title="8. CORS 跨域"></a>8. CORS 跨域</h2><p>符合Microsoft REST API准则的服务必须支持<a href="http://www.w3.org/TR/access-control/" target="_blank" rel="noopener">CORS(跨源资源共享)</a>。<br>服务应该支持CORS *的允许起源，并通过有效的OAuth令牌强制授权。<br>服务不应该支持带有源验证的用户凭据。<br>特殊情况可例外。</p><h3 id="8-1-客户端指导"><a href="#8-1-客户端指导" class="headerlink" title="8.1. 客户端指导"></a>8.1. 客户端指导</h3><p>Web开发人员通常不需要做任何特殊处理来利用CORS。<br>作为标准XMLHttpRequest调用的一部分，所有握手步骤都是不可见的。</p><p>许多其他平台（如.NET）已集成了对CORS的支持。</p><h4 id="8-1-1-避免额外的预检查"><a href="#8-1-1-避免额外的预检查" class="headerlink" title="8.1.1. 避免额外的预检查"></a>8.1.1. 避免额外的预检查</h4><p>由于CORS协议会触发向服务器添加额外往返的预检请求，因此，注重性能的应用程序可能会有意避免这些请求。<br>CORS背后的精神是避免对旧的不支持CORS功能的浏览器能够做出的任何简单的跨域请求进行预检。<br>所有其他请求都需要预检。</p><p>请求是“简单类型请求“，如果其方法是GET，HEAD或POST，并且除了Accept，Accept-Language和Content-Language之外它不包含任何请求标头，则可以免去预检。</p><p>对于POST请求，也允许使用Content-Type标头，但前提是其值为“application/x-www-form-urlencoded”，“multipart/form-data”或“text/plain”。<br>对于任何其他标头或值，将发生预检请求。</p><h3 id="8-2-服务指南"><a href="#8-2-服务指南" class="headerlink" title="8.2. 服务指南"></a>8.2. 服务指南</h3><p> 服务必须至少：</p><ul><li><p>了解浏览器在跨域请求上发送的Origin请求标头，以及他们在检查访问权限的预检OPTIONS 请求上发送的 Access-Control-Request-Method请求标头。</p></li><li><p>如果请求中存在Origin标头：</p><ul><li><p>如果请求使用 OPTIONS 方法并包含 Access-Control-Request-Method标头，则它是一个预检请求，用于在实际请求之前探测访问。否则，这是一个实际的请求。对于预检请求，除了执行以下步骤添加标头之外，服务必须不执行任何额外处理，并且必须返回 200 OK。对于非预检请求，除了请求的常规处理之外，还会添加以下标头。</p></li><li><p>服务向响应添加 Access-Control-Allow-Origin  标头，其中包含与Origin 请求标头相同的值。请注意，这需要服务来动态生成标头值。不需要cookie或任何其他形式的[用户凭证] <a href="http://www.w3.org/TR/access-control/#user-credentials" target="_blank" rel="noopener">cors-user-credentials</a>的资源可以使用通配符星号（*）进行响应。请注意，通配符仅在此处可接受，而不适用于下面描述的任何其他标头。</p></li><li><p>如果调用者需要访问不属于[简单响应头] <a href="http://www.w3.org/TR/access-control/#simple-header" target="_blank" rel="noopener">cors-simple-headers</a>集合中的响应头（Cache-Control，Content-Language，Content-Type，Expires，Last-Modified，Pragma），同时添加一个Access-Control-Expose-Headers标头，其中包含客户端应有权访问的其他响应标头名称列表。<br>[*]译者注：在跨域请求时，响应中的大部分header，需要服务端同意才能拿到，客户端跨域增加 Access-Control-Expose-Headers: content-type, cache …… 等标头来告知服务器。</p></li><li><p>如果请求需要cookie，则添加一个Access-Control-Allow-Credentials头，并将其设置为“true”。</p></li><li><p>如果请求是预检请求(见第一个项目符号)，则服务必须满足:</p><ul><li>添加一个Access-Control-Allow-Headers响应标头，其中包含允许客户端使用的请求标头名称列表。这个列表只需要包含不在[简单请求头][rs-simple-headers] (Accept、Accept- language、Content-Language)集合中的头。如果服务接受的报头没有限制，则服务可以简单地返回与客户机发送的访问-控制-请求-报头报头相同的值。</li><li>添加一个Access-Control-Allow-Methods响应头，其中包含允许调用方使用的HTTP方法列表。</li></ul></li></ul></li></ul><p>添加一个Access-Control-Max-Age pref</p><p>响应头，其中包含此预检前响应有效的秒数(因此可以在后续实际请求之前避免)。注意，虽然习惯上使用较大的值，比如2592000(30天)，但是许多浏览器会自动设置一个更低的限制(例如，5分钟)。</p><p>众所周知，由于浏览器预检响应缓存很弱，因此预检响应的额外往返会损害性能。<br> [*]译者注：获取预检OPTIONS调用会造成很大开销，而且也浏览器的缓存能力也很赢弱，而且部分浏览器也不会理会access-control-max-age的设置值，如Chrome/Blink 就硬编码为10分钟（600秒）。详见[<a href="https://chromium.googlesource.com/chromium/blink/+/master/Source/core/loader/CrossOriginPreflightResultCache.cpp#40]" target="_blank" rel="noopener">https://chromium.googlesource.com/chromium/blink/+/master/Source/core/loader/CrossOriginPreflightResultCache.cpp#40]</a></p><p>注重性能端的交互式 Web客户端使用的服务端应该避免使用导致预检的请求。</p><ul><li><p>对于GET和HEAD调用，请避免要求不属于上述简单集的请求标头。最好是允许将它们作为查询参数提供。</p><ul><li>Authorization标头不是简单集的一部分，因此对于需要验证的资源，必须通过“access_token”查询参数发送验证令牌。请注意，不建议在URL中传递身份验证令牌，因为它可能导致令牌记录在服务器日志中，并暴露给有权访问这些日志的任何人。通过URL接受身份验证令牌的服务必须采取措施来降低安全风险，例如使用短期身份验证令牌，禁止记录身份验证令牌以及控制对服务器日志的访问。</li></ul></li><li><p>避免要求cookie。如果设置了“withCredentials”属性，XmlHttpRequest将仅在跨域请求上发送cookie; 这也会导致预检请求。</p><ul><li>需要基于cookie的身份验证的服务必须使用“动态验证码（dynamic canary）” [*]译者注：服务器生成某种验证码，客户端获取后，服务器再进行验证的操作。来保护所有接受cookie的API。</li></ul></li><li><p>对于POST调用，在适用的情况下，选择简单的内容类型(“application/x-www-form-urlencoded”、“multipart/form-data”、“text/plain”)。其他任何内容类型都会引发预检请求。</p><ul><li>服务不得以避免CORS预检请求的名义违反其他API指南。由于内容类型的原因，大多数POST请求实际上需要预检请求。</li><li>如果非要取消预检工作，那么服务支持的其他的替代数据传输机制必须遵循本指南。</li></ul></li></ul><p>此外，当适当的服务可以支持JSONP模式时，只需简单的GET跨域访问。<br>在JSONP中，服务采用指示格式的参数(<em>$format=json</em>)和表示回调的参数(<em>$callback=someFunc</em>)，并返回一个 text/javascript 文档，其中包含用指定名称封装在函数调用中的JSON响应。<br>更多关于JSONP的信息，请访问Wikipedia: <a href="https://en.wikipedia.org/wiki/JSONP" target="_blank" rel="noopener">JSONP</a>。</p><h2 id="9-集合-Collections"><a href="#9-集合-Collections" class="headerlink" title="9. 集合 Collections"></a>9. 集合 Collections</h2><h3 id="9-1-Item-keys"><a href="#9-1-Item-keys" class="headerlink" title="9.1. Item keys"></a>9.1. Item keys</h3><p>服务可以支持集合中每个项的持久标识符(主键)，该标识符应用JSON表示为”id” , 这些持久标识符通常用作项目的key。</p><p>支持持久标识符(主键)的集合可以支持增量查询。</p><h3 id="9-2-序列化-Serialization"><a href="#9-2-序列化-Serialization" class="headerlink" title="9.2. 序列化 Serialization"></a>9.2. 序列化 Serialization</h3><p>集合使用标准数组表示法以JSON表示。</p><h3 id="9-3-Collection-URL-patterns-集合的URL匹配"><a href="#9-3-Collection-URL-patterns-集合的URL匹配" class="headerlink" title="9.3. Collection URL patterns 集合的URL匹配"></a>9.3. Collection URL patterns 集合的URL匹配</h3><p>集合在顶级时直接位于服务的根目录下，或者作用于该资源时作为另一个资源下的段。</p><p>例如:</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/people</code></pre><p>服务必须尽可能支持“/” 匹配。<br>例如:</p><pre class=" language-http"><code class="language-http">GET https://{serviceRoot}/{collection}/{id}</code></pre><p>Where:</p><ul><li>{serviceRoot} – 站点URL (site URL) + 服务的根路径的组合</li><li>{collection} – 集合的名称，未缩写，复数</li><li>{id} – 唯一id属性的值. 当使用 “/“ 匹配必须属于 string/number/guid value 不带引号，转义正确以适应URL。</li></ul><h4 id="9-3-1-嵌套集合和属性-Nested-collections-and-properties"><a href="#9-3-1-嵌套集合和属性-Nested-collections-and-properties" class="headerlink" title="9.3.1. 嵌套集合和属性 Nested collections and properties"></a>9.3.1. 嵌套集合和属性 Nested collections and properties</h4><p>集合项可以包含其他集合。<br>例如，用户集合可能包含多个地址的用户资源:</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/people/123/addresses</code></pre><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"value"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> <span class="token property">"street"</span><span class="token operator">:</span> <span class="token string">"1st Avenue"</span><span class="token punctuation">,</span> <span class="token property">"city"</span><span class="token operator">:</span> <span class="token string">"Seattle"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> <span class="token property">"street"</span><span class="token operator">:</span> <span class="token string">"124th Ave NE"</span><span class="token punctuation">,</span> <span class="token property">"city"</span><span class="token operator">:</span> <span class="token string">"Redmond"</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="9-4-大集合-Big-collections"><a href="#9-4-大集合-Big-collections" class="headerlink" title="9.4. 大集合 Big collections"></a>9.4. 大集合 Big collections</h3><p>随着数据的增长，集合也在增长。所以计划采用分页对所有服务都很重要。<br>因此，当数据包含多页时，序列化有效负载(payload)必须适当地包含下一页的不透明URL。<br>有关详细信息，请参阅分页指南。</p><p>客户端必须能够恰当的处理请求返回的任何给定的分页或非分页集合数据。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"value"</span><span class="token operator">:</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"Item 1"</span><span class="token punctuation">,</span><span class="token property">"price"</span><span class="token operator">:</span> <span class="token number">99.95</span><span class="token punctuation">,</span><span class="token property">"sizes"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> … <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> … <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"Item 99"</span><span class="token punctuation">,</span><span class="token property">"price"</span><span class="token operator">:</span> <span class="token number">59.99</span><span class="token punctuation">,</span><span class="token property">"sizes"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"@nextLink"</span><span class="token operator">:</span> <span class="token string">"{opaqueUrl}"</span><span class="token punctuation">}</span></code></pre><h3 id="9-5-Changing-collections"><a href="#9-5-Changing-collections" class="headerlink" title="9.5. Changing collections"></a>9.5. Changing collections</h3><p>POST请求不是幂等的。<br>这意味着发送到具有完全相同的有效负载(payload)的集合资源的两次POST请求可能导致在该集合中创建多个项。<br>[*]译者注：相同的数据两次POST操作，可能导致该集合创建多次。<br>例如，对于具有服务器端生成的id的项的插入操作，通常就是这种情况。</p><p>例如，以下请求:</p><pre class=" language-http"><code class="language-http">POST https://api.contoso.com/v1.0/people</code></pre><p>会导致响应，指示新集合项的位置：</p><pre class=" language-http"><code class="language-http">201 Created<span class="token header-name keyword">Location:</span> https://api.contoso.com/v1.0/people/123</code></pre><p>一旦再次执行，可能会导致创建另一个资源：</p><pre class=" language-http"><code class="language-http">201 Created<span class="token header-name keyword">Location:</span> https://api.contoso.com/v1.0/people/124</code></pre><p>而PUT请求则需要使用相应的键来指示集合项:</p><pre class=" language-http"><code class="language-http">PUT https://api.contoso.com/v1.0/people/123</code></pre><h3 id="9-6-Sorting-collections"><a href="#9-6-Sorting-collections" class="headerlink" title="9.6. Sorting collections"></a>9.6. Sorting collections</h3><p>可以基于属性值对集合查询的结果进行排序。<br>该属性由_$orderBy_查询参数的值确定。</p><p><em>$orderBy</em> 参数的值包含用于对项目进行排序表达式列表，用逗号分隔的。<br>这种表达式的特殊情况是属性路径终止于基本属性。</p><p>表达式可以包含升序的后缀“asc”或降序的后缀“desc”，它们与属性名之间用一个或多个空格分隔。<br>如果没有指定“asc”或“desc”，则服务必须按照指定的属性以升序排序。</p><p>空值(NULL)必须排序为“小于”非空值。</p><p>必须根据第一个表达式的结果值对项进行排序，然后根据第二个表达式的结果值对第一个表达式具有相同值的项进行排序，以此类推。<br>排序顺序是属性类型的固有顺序。</p><p>例如：</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/people?$orderBy=name</code></pre><p>将返回按name进行升序排序的所有人员。</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/people?$orderBy=name desc</code></pre><p>将返回按name进行降序排序的所有人。</p><p>可以通过逗号分隔的属性名称列表以及可选方向限定符来指定子排序。</p><p>例如：</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/people?$orderBy=name desc,hireDate</code></pre><p>将返回按姓名降序排列的所有人员，并按雇佣日期降序排列的次要排序。</p><p>排序必须与筛选相结合，如下:</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/people?$filter=name eq 'david'&amp;$orderBy=hireDate</code></pre><p>将返回所有名称为David的人，按雇佣日期按升序排列。</p><h4 id="9-6-1-Interpreting-a-sorting-expression"><a href="#9-6-1-Interpreting-a-sorting-expression" class="headerlink" title="9.6.1. Interpreting a sorting expression"></a>9.6.1. Interpreting a sorting expression</h4><p>跨页面的排序参数必须一致，因为客户端和服务器端分页都依赖该排序该参数进行排序。</p><p>如果服务不支持按_$orderBy_表达式中命名的属性排序，则服务必须按照“响应不支持的请求”部分中定义的错误消息进行响应。</p><h3 id="9-7-Filtering"><a href="#9-7-Filtering" class="headerlink" title="9.7. Filtering"></a>9.7. Filtering</h3><p>$filter_querystring 参数允许客户端通过URL过滤集合。<br>使用_$filter_指定的表达式将为集合中的每个资源求值，只有表达式求值为true的项才包含在响应中。<br>表达式计算为false或null的资源，或由于权限而不可用的引用属性，将从响应中省略。</p><p>例如:返回所有产品的价格低于10.00美元</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/products?$filter=price lt 10.00</code></pre><p>$filter_选项的值是 一个布尔表达式 表示 price less than 10.00。</p><h4 id="9-7-1-Filter-operations"><a href="#9-7-1-Filter-operations" class="headerlink" title="9.7.1. Filter operations"></a>9.7.1. Filter operations</h4><p>支持_$filter_的服务应该支持以下最小操作集。</p><table><thead><tr><th>Operator</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>Comparison Operators</td><td></td><td></td></tr><tr><td>eq</td><td>Equal</td><td>city eq ‘Redmond’</td></tr><tr><td>ne</td><td>Not equal</td><td>city ne ‘London’</td></tr><tr><td>gt</td><td>Greater than</td><td>price gt 20</td></tr><tr><td>ge</td><td>Greater than or equal</td><td>price ge 10</td></tr><tr><td>lt</td><td>Less than</td><td>price lt 20</td></tr><tr><td>le</td><td>Less than or equal</td><td>price le 100</td></tr><tr><td>Logical Operators</td><td></td><td></td></tr><tr><td>and</td><td>Logical and</td><td>price le 200 and price gt 3.5</td></tr><tr><td>or</td><td>Logical or</td><td>price le 3.5 or price gt 200</td></tr><tr><td>not</td><td>Logical negation</td><td>not price le 3.5</td></tr><tr><td>Grouping Operators</td><td></td><td></td></tr><tr><td>( )</td><td>Precedence grouping</td><td>(priority eq 1 or city eq ‘Redmond’) and price gt 100</td></tr></tbody></table><h4 id="9-7-2-Operator-examples"><a href="#9-7-2-Operator-examples" class="headerlink" title="9.7.2. Operator examples"></a>9.7.2. Operator examples</h4><p>下面的示例说明了每个逻辑操作符的用法和语义。</p><p>示例:所有名称等于“Milk”的产品</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/products?$filter=name eq 'Milk'</code></pre><p>示例:所有名称不等于“Milk”的产品</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/products?$filter=name ne 'Milk'</code></pre><p>示例:所有标有“Milk”的产品价格都低于2.55:</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/products?$filter=name eq 'Milk' and price lt 2.55</code></pre><p>示例:所有标有“Milk”字样或价格低于2.55美元的产品:</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/products?$filter=name eq 'Milk' or price lt 2.55</code></pre><p>示例:所有名称为“牛奶”或“鸡蛋”且价格低于2.55的产品:</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/products?$filter=(name eq 'Milk' or name eq 'Eggs') and price lt 2.55</code></pre><h4 id="9-7-3-Operator-precedence"><a href="#9-7-3-Operator-precedence" class="headerlink" title="9.7.3. Operator precedence"></a>9.7.3. Operator precedence</h4><p>在计算_$filter_表达式时，服务使用以下操作符优先级。<br>操作符按类别按优先级从高到低排列。<br>同一类别的运算符具有同等优先级:<br>| Group           | Operator | Description           |<br>|:—————-|:———|:———————-|<br>| Grouping        | ( )      | Precedence grouping   |<br>| Unary           | not      | Logical Negation      |<br>| Relational      | gt       | Greater Than          |<br>|                 | ge       | Greater than or Equal |<br>|                 | lt       | Less Than             |<br>|                 | le       | Less than or Equal    |<br>| Equality        | eq       | Equal                 |<br>|                 | ne       | Not Equal             |<br>| Conditional AND | and      | Logical And           |<br>| Conditional OR  | or       | Logical Or            |</p><h3 id="9-8-Pagination"><a href="#9-8-Pagination" class="headerlink" title="9.8. Pagination"></a>9.8. Pagination</h3><p>返回集合的RESTful API可能返回部分集。<br>这些服务的消费者清楚将获得部分结果集，并能正确地翻页以检索整个结果集。</p><p>RESTful API可能支持两种形式的分页。<br>服务器驱动的分页：通过在多个响应有效载荷上强制分页请求来减轻拒绝服务攻击。<br>客户端驱动的分页：允许客户机只请求它在给定时间可以使用的资源数量。</p><p>跨页面的排序和筛选参数必须一致，因为客户端和服务器端分页都完全兼容于筛选和排序。</p><h4 id="9-8-1-Server-driven-paging"><a href="#9-8-1-Server-driven-paging" class="headerlink" title="9.8.1. Server-driven paging"></a>9.8.1. Server-driven paging</h4><p>分页响应必须通过在响应中包含延续分页标记来告诉客户端这是部分结果。<br>没有延续分页标记意味着没有下一页了。</p><p>客户端必须将延续URL视为不透明的，这意味着在迭代一组部分结果时，查询选项可能不会更改。</p><p>例如:</p><pre class=" language-http"><code class="language-http"><span class="token request-line"><span class="token property">GET</span> http://api.contoso.com/v1.0/people HTTP/1.1</span><span class="token header-name keyword">Accept:</span> application/json<span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token punctuation">,</span>  <span class="token string">"value"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"@nextLink"</span><span class="token punctuation">:</span> <span class="token string">"{opaqueUrl}"</span><span class="token punctuation">}</span></span></code></pre><h4 id="9-8-2-Client-driven-paging"><a href="#9-8-2-Client-driven-paging" class="headerlink" title="9.8.2. Client-driven paging"></a>9.8.2. Client-driven paging</h4><p>客户端可以使用<em>$top_和</em>$skip_查询参数来指定返回的结果数量和跳过的集合数量。</p><p>服务器应遵守客户端指定的参数; 但是，客户端必须做好准备处理包含不同页面大小的响应或包含延续分页标记的响应。</p><p>当客户端同时提供<em>$top_和</em>$skip_时，服务器应该首先应用<em>$skip_，然后对集合应用</em>$top_。</p><p>注意:如果服务器不能执行<em>$top_和/或</em>$skip_，服务器必须返回一个错误给客户端，告知它，而不是忽略该查询参数。<br>这将避免客户端对返回的数据做出假设的风险。</p><p>实例:</p><pre class=" language-http"><code class="language-http"><span class="token request-line"><span class="token property">GET</span> http://api.contoso.com/v1.0/people?$top=5&amp;$skip=2 HTTP/1.1</span><span class="token header-name keyword">Accept:</span> application/json<span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token punctuation">,</span>  <span class="token string">"value"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span></code></pre><h4 id="9-8-3-Additional-considerations"><a href="#9-8-3-Additional-considerations" class="headerlink" title="9.8.3. Additional considerations"></a>9.8.3. Additional considerations</h4><p><strong>固定的顺序先决条件:</strong>两种分页形式都依赖于具有固定顺序的项的集合。<br>服务器必须使用额外的排序(通常是按键排序)来补充任何指定的顺序标准，以确保项目始终保持一致的顺序。</p><p><strong>缺失/重复结果：</strong>即使服务器强制执行一致的排序顺序，结果也可能会因创建或删除其他资源而导致丢失或重复。<br>客户端必须准备好处理这些差异。<br>服务器应该总是编码最后读取记录的记录ID，帮助客户端管理重复/丢失的结果。</p><p><strong>结合客户端和服务驱动的分页：</strong>请注意，客户端驱动的分页不排除服务器驱动的分页。<br>如果客户端请求的页面大小大于服务器支持的默认页面大小，则预期响应将是客户端指定的结果数，否则按服务端分页设置的指定分页。</p><p><strong>页面大小：</strong>客户端可以通过指定_$maxpagesize_首选项来请求具有特定页面大小的服务端驱动的分页。<br>如果指定的页面大小小于服务端的默认页面大小，服务器应该遵循此首选项。</p><p><strong>分页嵌入式集合：</strong>客户端驱动的分页和服务端驱动的分页都可以应用于嵌入式集合。<br>如果服务端对嵌入式集合进行分页，则必须包含其他适当的延续分页标记。</p><p><strong>记录集计数：</strong>想要知道所有页面中的完整记录数的开发人员可以包含查询参数_$ count=true_，以告知服务端包含响应中的记录数。</p><h3 id="9-9-Compound-collection-operations"><a href="#9-9-Compound-collection-operations" class="headerlink" title="9.9. Compound collection operations"></a>9.9. Compound collection operations</h3><p>筛选、排序和分页操作都可以针对给定的集合执行。<br>当这些操作一起执行时，评估顺序必须是:</p><ol><li><strong>筛选</strong>。 这包括作为AND操作执行的所有范围表达式。</li><li><strong>排序</strong>。 可能已过滤的列表根据排序条件进行排序。</li><li><strong>分页</strong>。 经过筛选和排序的列表上显示了实现分页视图。这适用于服务器驱动的分页和客户端驱动的分页。</li></ol><h2 id="10-增量查询-Delta-queries"><a href="#10-增量查询-Delta-queries" class="headerlink" title="10. 增量查询 Delta queries"></a>10. 增量查询 Delta queries</h2><p>服务可以选择支持Delta查询。<br>[*]译者注：增量查询可以使客户端能够发现新创建、更新或者删除的实体，无需使用每个请求对目标资源执行完全读取。这让客户端的调用更加高效。  </p><h3 id="10-1-增量链接-Delta-links"><a href="#10-1-增量链接-Delta-links" class="headerlink" title="10.1. 增量链接 Delta links"></a>10.1. 增量链接 Delta links</h3><p>增量(Delta)链接是不透明的、由服务生成的链接，客户端使用这些链接查询对结果的后续更改。</p><p>在概念层面上，delta链接基于一个定义查询，该查询描述正在跟踪更改的一组结果集。<br>delta链接编码并跟踪这些更改的实体集合，以及跟踪更改的起点。</p><p>如果查询包含筛选器，则响应必须只包含对匹配指定条件的实体的更改。<br>Delta查询的主要原则是:</p><ul><li>集合中的每个项目必须具有持久标识符（永久不变的主键）。该标识符应该表示为“id”。 此标识符由服务定义，客户端可以使用该字符串跨调用跟踪对象。</li><li>delta 必须包含每个与指定条件新匹配的实体的条目，并且必须为每个不再符合条件的实体包含“@removed”条目。</li><li>重新调用查询并将其与原始结果集进行比较; 必须将当前集合中惟一的每个条目作为”add”操作返回，并且必须将原始集合中惟一的每个条目作为“remove”操作返回。。</li><li>以前与标准不匹配但现在匹配的每个实体必须作为”add”返回; 相反，先前与查询匹配但不再必须返回的每个实体必须作为“@removed”条目返回。</li><li>已更改的实体必须使用其标准表示形式包含在集合中。</li><li>服务可以向“@remove”节点添加额外的元数据，例如删除的原因或“removed at”时间戳。我们建议团队与Microsoft REST API指导原则工作组协调，以帮助维护一致性。</li></ul><p>Delta链接不能编码任何客户端 top 或 skip 值。</p><h3 id="10-2-Entity-representation"><a href="#10-2-Entity-representation" class="headerlink" title="10.2. Entity representation"></a>10.2. Entity representation</h3><p>添加和更新的实体使用其标准表示在实体集中表示。<br>从集合的角度来看，添加或更新的实体之间没有区别。</p><p>删除的实体仅使用其“id”和“@removed”节点表示。<br>“@removed”节点的存在必须表示从集合中删除条目。</p><h3 id="10-3-Obtaining-a-delta-link"><a href="#10-3-Obtaining-a-delta-link" class="headerlink" title="10.3. Obtaining a delta link"></a>10.3. Obtaining a delta link</h3><p>通过查询集合或实体并附加 $delta 查询字符串参数来获得 Delta 链接。</p><p>例如：</p><pre class=" language-http"><code class="language-http"><span class="token request-line"><span class="token property">GET</span> https://api.contoso.com/v1.0/people?$deltaHTTP/1.1</span><span class="token header-name keyword">Accept:</span> application/json<span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token string">"value"</span><span class="token punctuation">:</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Matt"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Mark"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"@deltaLink"</span><span class="token punctuation">:</span> <span class="token string">"{opaqueUrl}"</span><span class="token punctuation">}</span></span></code></pre><p>注意:如果集合分页，deltaLink将只出现在最后一页，但必须反映对所有页面返回的数据的任何更改。</p><h3 id="10-4-Contents-of-a-delta-link-response"><a href="#10-4-Contents-of-a-delta-link-response" class="headerlink" title="10.4. Contents of a delta link response"></a>10.4. Contents of a delta link response</h3><p>添加/更新的条目必须以常规JSON对象的形式出现，并带有常规项目属性。<br>在常规表示中返回添加/修改的项，允许客户端使用基于“id”字段的标准合并概念将它们合并到现有的“缓存”中。</p><p>从定义的集合中删除的条目必须包含在响应中。<br>从集合中删除的项必须仅使用它们的“id”和“@remove”节点表示。</p><h3 id="10-5-Using-a-delta-link"><a href="#10-5-Using-a-delta-link" class="headerlink" title="10.5. Using a delta link"></a>10.5. Using a delta link</h3><p>客户端通过调用delta链接上的GET方法请求更改。<br>客户端必须按原样使用delta URL——换句话说，客户端不能以任何方式修改URL(例如，解析URL并添加额外的查询字符串参数)。</p><p>在这个例子中:</p><pre class=" language-http"><code class="language-http"><span class="token request-line"><span class="token property">GET</span> https://{opaqueUrl} HTTP/1.1</span><span class="token header-name keyword">Accept:</span> application/json<span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token string">"value"</span><span class="token punctuation">:</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Mat"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Marc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"@removed"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Luc"</span><span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"@deltaLink"</span><span class="token punctuation">:</span> <span class="token string">"{opaqueUrl}"</span><span class="token punctuation">}</span></span></code></pre><p>针对delta链接的请求的结果可以跨多个页面，但是必须由服务跨所有页面进行排序，以便在应用到包含delta链接的响应时确保得到确定的结果。</p><p>如果没有发生任何更改，则响应是一个空集合，其中包含一个delta链接，用于根据请求进行后续更改。<br>这个delta链接可能与delta链接相同，从而导致更改的空集合。</p><p>如果delta链接不再有效，则服务必须使用_410 Gone_响应。响应应该包含一个Location头，客户端可以使用它来检索新的基线结果集。</p><h2 id="11-JSON-standardizations"><a href="#11-JSON-standardizations" class="headerlink" title="11. JSON standardizations"></a>11. JSON standardizations</h2><h3 id="11-1-JSON-formatting-standardization-for-primitive-types"><a href="#11-1-JSON-formatting-standardization-for-primitive-types" class="headerlink" title="11.1. JSON formatting standardization for primitive types"></a>11.1. JSON formatting standardization for primitive types</h3><p>必须按照[RFC8259] [rfc-8259]的规则将原始值序列化为JSON。</p><p>** 64位整数的重要说明：** JavaScript将静默截断大于“Number.MAX_SAFE_INTEGER”（2 ^ 53-1）的整数或小于“Number.MIN_SAFE_INTEGER”（-2 ^ 53 + 1）的数字。<br>** 如果预期服务返回超出安全值范围的整数值，请强烈考虑将该值作为字符串返回，以便最大化互操作性并避免数据丢失。</p><h3 id="11-2-Guidelines-for-dates-and-times"><a href="#11-2-Guidelines-for-dates-and-times" class="headerlink" title="11.2. Guidelines for dates and times"></a>11.2. Guidelines for dates and times</h3><h4 id="11-2-1-Producing-dates"><a href="#11-2-1-Producing-dates" class="headerlink" title="11.2.1. Producing dates"></a>11.2.1. Producing dates</h4><p>服务必须使用“DateLiteral”格式生成日期，并且应该使用“Iso8601Literal”格式，除非有令人信服的理由不这样做。<br>使用“StructuredDateLiteral”格式的服务绝不能使用“T”类型生成日期，除非需要额外的精度，并且明确不支持ECMAScript客户端。<br>(非规范性陈述:当决定要标准化哪一种特定的“日期类型（DateKind）”时，偏好的大致顺序是“E, C, U, W, O, X, I, T”。<br>这是对ECMAScript、.NET和c++程序员的优化，按顺序排列)。</p><h4 id="11-2-2-Consuming-dates"><a href="#11-2-2-Consuming-dates" class="headerlink" title="11.2.2. Consuming dates"></a>11.2.2. Consuming dates</h4><p>服务必须接受来自使用相同<code>DateLiteral</code>格式（包括它们生成的<code>DateKind</code>，如果适用）的客户的日期，并且应该使用任何<code>DateLiteral</code>格式接受日期。</p><h4 id="11-2-3-Compatibility"><a href="#11-2-3-Compatibility" class="headerlink" title="11.2.3. Compatibility"></a>11.2.3. Compatibility</h4><p>服务必须对相同类型的所有资源使用相同的<code>DateLiteral</code>格式（包括相同的<code>DateKind</code>，如果适用），并且应该对所有资源使用相同的<code>DateLiteral</code>格式（和<code>DateKind</code>，如果适用） 整个服务。</p><p>服务生成的<code>DateLiteral</code>格式的任何更改（包括<code>DateKind</code>，如果适用）和服务所接受的<code>DateLiteral</code>格式（和DateKind`，如果适用）的任何缩减都必须被视为破坏性的更改。<br>任何被服务接受的“DateLiteral”格式的扩展都不会被认为是破坏性的更改。</p><h3 id="11-3-JSON-serialization-of-dates-and-times"><a href="#11-3-JSON-serialization-of-dates-and-times" class="headerlink" title="11.3. JSON serialization of dates and times"></a>11.3. JSON serialization of dates and times</h3><p>使用JSON往返序列化日期是一个难题。<br>尽管ECMAScript支持大多数内置类型的文字，但它没有为日期定义文字格式。<br>Web已经围绕着[ISO 8601日期格式(ISO 8601)的ECMAScript子集][ISO -8601] [ISO -8601进行了合并，但是在某些情况下，这种格式是不可取的。<br>对于这些情况，本文档定义了一个JSON序列化格式，可用于明确表示不同格式的日期。<br>其他序列化格式(如XML)可以从这种格式派生出来。</p><h4 id="11-3-1-The-DateLiteral-format"><a href="#11-3-1-The-DateLiteral-format" class="headerlink" title="11.3.1. The DateLiteral format"></a>11.3.1. The <code>DateLiteral</code> format</h4><p>使用以下语法对JSON中表示的日期进行序列化。<br>非正式地，<code>DateValue</code>是ISO 8601格式的字符串或JSON对象，它包含两个名为<code>kind</code>和<code>value</code>的属性，它们共同定义了一个时间点。</p><p>下面的语法不是上下文无关的; 特别是，<code>DateValue</code>的解释取决于<code>DateKind</code>的值，但这将描述格式所需的产品数量降到最低。</p><pre><code>DateLiteral:  Iso8601Literal  StructuredDateLiteralIso8601Literal:  A string literal as defined in http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15. Note that the full grammar for ISO 8601 (such as &quot;basic format&quot; without separators) is not supported.  All dates default to UTC unless specified otherwise.StructuredDateLiteral:  { DateKindProperty , DateValueProperty }  { DateValueProperty , DateKindProperty }DateKindProperty  &quot;kind&quot; : DateKindDateKind:  &quot;C&quot;            ; see below  &quot;E&quot;            ; see below  &quot;I&quot;            ; see below  &quot;O&quot;            ; see below  &quot;T&quot;            ; see below  &quot;U&quot;            ; see below  &quot;W&quot;            ; see below  &quot;X&quot;            ; see belowDateValueProperty:  &quot;value&quot; : DateValueDateValue:  UnsignedInteger        ; not defined here  SignedInteger        ; not defined here  RealNumber        ; not defined here  Iso8601Literal        ; as above</code></pre><h4 id="11-3-2-Commentary-on-date-formatting"><a href="#11-3-2-Commentary-on-date-formatting" class="headerlink" title="11.3.2. Commentary on date formatting"></a>11.3.2. Commentary on date formatting</h4><p>使用“Iso8601Literal”生产的“DateLiteral”相对简单。<br>下面是一个名为“creationDate”的对象的例子，该对象的属性设置为2015年2月13日下午1:15 UTC:</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span> <span class="token property">"creationDate"</span> <span class="token operator">:</span> <span class="token string">"2015-02-13T13:15Z"</span> <span class="token punctuation">}</span></code></pre><p>“StructuredDateLiteral”由一个“DateKind”和一个“DateValue”组成，其有效值(及其解释)取决于“DateKind”。下表描述了有效的组合及其意义:</p><table><thead><tr><th>DateKind</th><th>DateValue</th><th>Colloquial Name &amp; Interpretation</th><th>More Info</th></tr></thead><tbody><tr><td>C</td><td>UnsignedInteger</td><td>“CLR”; number of milliseconds since midnight January 1, 0001; negative values are not allowed. <em>See note below.</em></td><td><a href="https://msdn.microsoft.com/en-us/library/System.DateTime(v=vs.110).aspx" target="_blank" rel="noopener">MSDN</a></td></tr><tr><td>E</td><td>SignedInteger</td><td>“ECMAScript”; number of milliseconds since midnight, January 1, 1970.</td><td><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.1" target="_blank" rel="noopener">ECMA International</a></td></tr><tr><td>I</td><td>Iso8601Literal</td><td>“ISO 8601”; a string limited to the ECMAScript subset.</td><td></td></tr><tr><td>O</td><td>RealNumber</td><td>“OLE Date”; integral part is the number of days since midnight, December 31, 1899, and fractional part is the time within the day (0.5 = midday).</td><td><a href="https://docs.microsoft.com/en-us/windows/desktop/api/oleauto/nf-oleauto-varianttimetosystemtime" target="_blank" rel="noopener">MSDN</a></td></tr><tr><td>T</td><td>SignedInteger</td><td>“Ticks”; number of ticks (100-nanosecond intervals) since midnight January 1, 1601. <em>See note below.</em></td><td><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724290(v=vs.85).aspx" target="_blank" rel="noopener">MSDN</a></td></tr><tr><td>U</td><td>SignedInteger</td><td>“UNIX”; number of seconds since midnight, January 1, 1970.</td><td><a href="https://msdn.microsoft.com/en-us/library/1f4c8f33.aspx" target="_blank" rel="noopener">MSDN</a></td></tr><tr><td>W</td><td>SignedInteger</td><td>“Windows”; number of milliseconds since midnight January 1, 1601. <em>See note below.</em></td><td><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724290(v=vs.85).aspx" target="_blank" rel="noopener">MSDN</a></td></tr><tr><td>X</td><td>RealNumber</td><td>“Excel”; as for <code>O</code> but the year 1900 is incorrectly treated as a leap year, and day 0 is “January 0 (zero).”</td><td><a href="http://support.microsoft.com/kb/214326?wa=wsignin1.0" target="_blank" rel="noopener">Microsoft Support</a></td></tr></tbody></table><p><strong>注意“C”和“W”类型:</strong>本机CLR和Windows时间由100纳秒的“滴答”值表示。<br>要与精度有限的ECMAScript客户端进行互操作，必须将这些值转换为毫秒，并在(反)序列化为“DateLiteral”时从毫秒转换为毫秒。<br>1毫秒相当于10,000 ticks。</p><p><strong>对于<code>T</code>类的重要说明：</strong>这种类型保留了Windows本机时间格式的完全保真度（并且可以轻松转换为本机CLR格式），但与ECMAScript客户端不兼容。<br>因此，它的使用应该仅限于那些既需要额外精度又不需要与ECMAScript客户端互操作的场景。</p><p>以下是具有名为creationDate的属性的对象的相同示例，该属性设置为2015年2月13日下午1:15. UTC，使用多种格式：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span>  <span class="token punctuation">{</span> <span class="token property">"creationDate"</span> <span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"kind"</span> <span class="token operator">:</span> <span class="token string">"O"</span><span class="token punctuation">,</span> <span class="token property">"value"</span> <span class="token operator">:</span> <span class="token number">42048.55</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> <span class="token property">"creationDate"</span> <span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"kind"</span> <span class="token operator">:</span> <span class="token string">"E"</span><span class="token punctuation">,</span> <span class="token property">"value"</span> <span class="token operator">:</span> <span class="token number">1423862100000</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>将类型与值分开的一个好处是，一旦客户端知道特定服务使用的类型，它就可以很容易的解释该值。<br>在值为数字的常见情况下，这使开发人员更容易编码：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// We know this service always gives out ECMAScript-format dates</span><span class="token keyword">var</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>serverResponse<span class="token punctuation">.</span>someObject<span class="token punctuation">.</span>creationDate<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="11-4-Durations"><a href="#11-4-Durations" class="headerlink" title="11.4. Durations"></a>11.4. Durations</h3><p>[持续时间] <a href="http://en.wikipedia.org/wiki/ISO_8601#Durations" target="_blank" rel="noopener">wikipedia-iso8601-durations</a>需要按照[ISO 8601] <a href="http://en.wikipedia.org/wiki/ISO_8601#Durations" target="_blank" rel="noopener">wikipedia-iso8601-durations</a>进行序列化。<br>持续时间“由格式’P [n] Y [n] M [n] DT [n] H [n] M [n] S`表示。”<br>从标准：</p><ul><li>P是在持续时间表示开始时放置的持续时间指示符（历史上称为“时段”）。</li><li>Y是年份指示符，它遵循年数值。</li><li>M是月份指示符，它遵循月数值。</li><li>W是周指示符，它遵循周数值。</li><li>D是遵循天数值的日期指示符。</li><li>T是在表示的时间分量之前的时间指示符。</li><li>H是小时指示符，它遵循小时数值。</li><li>M是遵循分钟数值的分钟指示符。</li><li>S是秒指示符，它遵循秒数的值。</li></ul><p>例如，“P3Y6M4DT12H30M5S”表示“三年，六月，四天，十二小时，三十分钟和五秒”的持续时间。</p><h3 id="11-5-Intervals"><a href="#11-5-Intervals" class="headerlink" title="11.5. Intervals"></a>11.5. Intervals</h3><p>[间隔] <a href="http://en.wikipedia.org/wiki/ISO_8601#Time_intervals" target="_blank" rel="noopener">wikipedia-iso8601-intervals</a>被定义为[ISO 8601] <a href="http://en.wikipedia.org/wiki/ISO_8601#Time_intervals" target="_blank" rel="noopener">wikipedia-iso8601-intervals</a>的一部分。</p><ul><li>开始和结束，例如“2007-03-01T13：00：00Z / 2008-05-11T15：30：00Z”</li><li>开始和持续时间，例如“2007-03-01T13：00：00Z / P1Y2M10DT2H30M”</li><li>持续时间和结束，例如“P1Y2M10DT2H30M / 2008-05-11T15：30：00Z”</li><li>仅限持续时间，例如“P1Y2M10DT2H30M”，以及其他上下文信息</li></ul><h3 id="11-6-Repeating-intervals"><a href="#11-6-Repeating-intervals" class="headerlink" title="11.6. Repeating intervals"></a>11.6. Repeating intervals</h3><p>根据[ISO 8601] <a href="http://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals" target="_blank" rel="noopener">wikipedia-iso8601-repeatingintervals</a>，[重复间隔] <a href="http://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals" target="_blank" rel="noopener">wikipedia-iso8601-repeatingintervals</a>是：</p><blockquote><p>通过在区间表达式的开头添加“R [n] /”形成，其中R用作字母本身，[n]用重复次数代替。<br>省略[n]的值意味着无限次重复。</p></blockquote><p>例如，要从“2008-03-01T13：00：00Z”开始重复“P1Y2M10DT2H30M”的间隔五次，请使用“R5 / 2008-03-01T13：00：00Z / P1Y2M10DT2H30M”。</p><h2 id="12-Versioning"><a href="#12-Versioning" class="headerlink" title="12. Versioning"></a>12. Versioning</h2><p>*<em>所有符合Microsoft REST API准则的API都必须支持显式版本控制。<br>*</em>客户端可以指望服务随着时间的推移保持稳定至关重要，服务可以添加功能和进行更改至关重要。</p><h3 id="12-1-Versioning-formats"><a href="#12-1-Versioning-formats" class="headerlink" title="12.1. Versioning formats"></a>12.1. Versioning formats</h3><p>服务使用Major.Minor版本控制方案进行版本控制。<br>服务可以选择“主要”版本方案，在这种情况下标注为 “.0”，适用于本节中的所有其他规则。<br>支持指定REST API请求版本的两个选项：</p><ul><li>嵌入在请求URL的路径中，位于服务根目录的末尾：<code>https://api.contoso.com/v1.0/products/users</code></li><li>作为URL的查询字符串参数：<code>https://api.contoso.com/products/users?api-version=1.0</code></li></ul><p>选择两种方案的指导如下：<br>1.位于DNS端点后面的服务必须使用相同的版本控制机制。<br>2.在此方案中，跨端点的一致用户体验至关重要。 Microsoft REST API准则工作组建议，如果没有与组织的领导团队进行明确的对话，则不会创建新的顶级DNS端点。<br>3.即使通过API的未来版本，保证REST API的URL路径稳定性的服务也可以采用查询字符串参数机制。 这意味着API中描述的关系的命名和结构在API发布后无法再进行变化，即使在具有重大更改的版本中也是如此。<br>4.无法确保未来版本的URL路径稳定性的服务必须将该版本嵌入到URL路径中。</p><p>[编者注：]本处的TDL(top-level DNS endpoints)意思是指 <a href="https://api.contoso.com" target="_blank" rel="noopener">https://api.contoso.com</a> 这个api的域名，没有必要的话不要新增域名的方式来新增版本。</p><p>某些基础服务（如Microsoft的Azure Active Directory）可能会被部署在多个端点之后。<br>所以服务必须支持每个端点的版本控制机制，即使这意味着支持多种版本控制机制。</p><h4 id="12-1-1-Group-versioning"><a href="#12-1-1-Group-versioning" class="headerlink" title="12.1.1. Group versioning"></a>12.1.1. Group versioning</h4><p>组版本控制是一种可选功能，可以使用查询字符串参数机制在服务上提供。<br>组版本允许在公共版本控制名称下对API端点进行逻辑分组。<br>这允许开发人员查找单个版本号并在多个端点上使用它。<br>组版本号是众所周知的，服务应该拒绝任何无法识别的值。</p><p>在内部，服务将采用组版本并将其映射到相应的Major.Minor版本。</p><p>组版本格式定义为YYYY-MM-DD，例如2012-12-07 2012年12月7日。此日期版本控制格式仅适用于组版本，不应该用作Major.Minor版本控制的替代版本。</p><p>[*]译者注：API然后想着对用户长期保持不变，那确实很麻烦，可以选择按版本控制或者按日期控制，下面例子按日期进行分组，意思就是把次要的版本映射到某个组（日期）里面去。</p><h5 id="组版本控制实例"><a href="#组版本控制实例" class="headerlink" title="组版本控制实例"></a>组版本控制实例</h5><h5 id="Examples-of-group-versioning"><a href="#Examples-of-group-versioning" class="headerlink" title="Examples of group versioning"></a>Examples of group versioning</h5><table><thead><tr><th align="left">Group</th><th align="left">Major.Minor</th></tr></thead><tbody><tr><td align="left">2012-12-01</td><td align="left">1.0</td></tr><tr><td align="left"></td><td align="left">1.1</td></tr><tr><td align="left"></td><td align="left">1.2</td></tr><tr><td align="left">2013-03-21</td><td align="left">1.0</td></tr><tr><td align="left"></td><td align="left">2.0</td></tr><tr><td align="left"></td><td align="left">3.0</td></tr><tr><td align="left"></td><td align="left">3.1</td></tr><tr><td align="left"></td><td align="left">3.2</td></tr><tr><td align="left"></td><td align="left">3.3</td></tr></tbody></table><table><thead><tr><th>Version Format</th><th>Example</th><th>Interpretation</th></tr></thead><tbody><tr><td>{groupVersion}</td><td>2013-03-21, 2012-12-01</td><td>3.3, 1.2</td></tr><tr><td>{majorVersion}</td><td>3</td><td>3.0</td></tr><tr><td>{majorVersion}.{minorVersion}</td><td>1.2</td><td>1.2</td></tr></tbody></table><p>客户端可以指定组版本或Major.Minor版本：</p><p>实例：</p><pre class=" language-http"><code class="language-http">GET http://api.contoso.com/acct1/c1/blob2?api-version=1.0</code></pre><pre class=" language-http"><code class="language-http">PUT http://api.contoso.com/acct1/c1/b2?api-version=2011-12-07</code></pre><h3 id="12-2-When-to-version"><a href="#12-2-When-to-version" class="headerlink" title="12.2. When to version"></a>12.2. When to version</h3><p>服务必须增加其版本号以响应任何中断的API更改。<br>有关如何构成重大变更的详细讨论，请参阅以下部分。<br>如果需要，服务也可以增加它们的版本号来进行非中断更改。</p><p>使用新的主要版本号表示将来不推荐对现有客户端的支持。<br>在引入新的主要版本时，服务必须为现有客户提供明确的升级路径，并制定与其业务组策略一致的弃用计划。<br>服务应该为所有其他更改使用新的次要版本号。</p><p>版本化服务的在线文档必须指出每个先前API版本的当前支持状态，并提供最新版本的路径。</p><h3 id="12-3-Definition-of-a-breaking-change"><a href="#12-3-Definition-of-a-breaking-change" class="headerlink" title="12.3. Definition of a breaking change"></a>12.3. Definition of a breaking change</h3><p>对API契约(约定)的更改被认为是破坏性的更改。<br>影响API向后兼容性的更改是破坏性的更改。</p><p>团队可以根据业务需求定义向后兼容性。<br>例如，Azure在响应中定义了一个新的JSON字段，使其不向后兼容。<br>Office 365对向后兼容性的定义更宽松，允许将JSON字段添加到响应中。</p><p>破坏性改变的明显例子：<br>1.删除或重命名API或API参数<br>2.现有API的行为更改<br>3.错误代码和故障合同的变化<br>4.任何违反[最少惊动原则] <a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment" target="_blank" rel="noopener">principle-of-least-astonishment</a>的事情</p><p>服务必须明确定义它们对重大变化的定义，特别是关于向JSON响应添加新字段和使用默认字段添加新API参数。<br>与其他服务共存于DNS端点后面的服务必须在定义合同可扩展性方面保持一致。</p><p>[OData V4规范的这一部分]描述的适用变更<a href="http://docs.oasis-open.org/odata/odata/v4.0/errata02/os/complete/part1-protocol/odata-v4.0-errata02-os-part1-protocol-complete.html#_Toc406398209" target="_blank" rel="noopener">odata-breaking-changes</a>应该被视为所有服务必须考虑突破性变化的最小标准的一部分。</p><h2 id="13-Long-running-operations"><a href="#13-Long-running-operations" class="headerlink" title="13. Long running operations"></a>13. Long running operations</h2><p>长时间运行的操作（有时称为异步操作）往往对不同的人意味着不同的事情。<br>本节介绍了围绕不同类型的长时间运行操作的指南，并描述了这些类型的操作的线路协议和最佳实践。</p><p>1.一个或多个客户端必须能够同时监视和操作相同的资源。<br>2.系统的状态应该始终是可发现和可测试的。即使操作跟踪资源不再处于活动状态，客户端也应该能够确定系统状态。查询长期运行状态的行为本身应该遵循web原则：即具有统一接口语义的定义良好的资源。客户端可以在某些资源上发出GET以确定长时间运行的状态<br>3.长时间运行的操作应该适用于希望“解雇并忘记”的客户，以及希望积极监控结果并根据结果采取行动的客户。<br>4.取消并不明确意味着回滚。在每个API定义的情况下，它可能意味着回滚，或补偿，或完成，或部分完成等。在取消操作后，客户不应将服务返回到允许继续服务的一致状态。</p><p>[*]译者注：如果准备操作某种长时间运行的资源（设备或者作业）,如更新某物联网设备ip，这会导致此物联网设备重启或者掉线后重连，这中间的状态是不可控的，本节主要是说明如何对这种情况进行处理。</p><h3 id="13-1-Resource-based-long-running-operations-RELO"><a href="#13-1-Resource-based-long-running-operations-RELO" class="headerlink" title="13.1. Resource based long running operations (RELO)"></a>13.1. Resource based long running operations (RELO)</h3><p>基于资源的建模是将操作的状态编码在资源中，使用的wire协议是标准同步协议。<br>在这个模型中，状态转换被很好地定义，目标状态也被类似地定义。</p><p><em>这是长期运行操作的首选模型，应该尽可能使用 .</em> 避免LRO Wire协议的复杂性和机制使我们的用户和工具链更加简单。</p><p>一个示例：计算机重新启动，该操作本身同步完成，但虚拟机资源上的GET操作将可以随时查询，如下状态：“状态：重新启动”，“状态：正在运行”。</p><p>该模型可以集成推送通知。</p><p>虽然大多数操作可能是POST语义，但除了POST语义之外，服务可以通过路由支持PUT语义以简化其API。<br>例如，想要创建名为“db1”的数据库的用户可以调用：</p><pre class=" language-http"><code class="language-http">PUT https://api.contoso.com/v1.0/databases/db1</code></pre><p>在这种情况下，数据库端正在处理PUT操作。</p><p>服务也可以使用下面定义的混合。</p><h3 id="13-2-分阶段的长时间运行的操作"><a href="#13-2-分阶段的长时间运行的操作" class="headerlink" title="13.2. 分阶段的长时间运行的操作"></a>13.2. 分阶段的长时间运行的操作</h3><p>分阶段操作需要很长时间，而且通常是不可预测的完成时间，并且不提供在资源中建模的状态转换。<br>本节概述了服务应该用于显示这种长时间运行的操作的方法。</p><p>服务可以显示逐步操作。</p><blockquote><p>分阶段长时间运行的操作有时称为“异步”操作。<br>这会导致混淆，因为它将平台的元素(“Async/waiting”、“promises”、“futures”)与API操作的元素混合在一起。<br>本文档使用术语“分阶段长时间运行的操作”，或者通常只是“分阶段操作”，以避免混淆“异步”一词。</p></blockquote><p>服务必须对分阶段请求执行尽可能多的同步验证。<br>服务必须以同步方式对返回错误进行优先级排序，其目标是仅使用长时间运行的操作线协议处理“有效”操作。</p><p>对于定义为分阶段长时间运行的操作的API，即使操作可以立即完成，服务也必须经过分阶段长时间运行的操作流。<br>换句话说，api必须采用并坚持LRO模式，而不是根据环境改变模式。</p><h4 id="13-2-1-PUT"><a href="#13-2-1-PUT" class="headerlink" title="13.2.1. PUT"></a>13.2.1. PUT</h4><p>服务可以支持实体创建的PUT请求。</p><pre class=" language-http"><code class="language-http">PUT https://api.contoso.com/v1.0/databases/db1</code></pre><p>在这个场景中，_databases_段正在处理PUT操作。</p><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">202 Accepted</span></span><span class="token header-name keyword">Operation-Location:</span> https://api.contoso.com/v1.0/operations/123</code></pre><p>对于需要返回此处创建的201的服务，请使用下面描述的混合流。</p><p>202 Accepted应该不返回任何身体。<br>201 Created案例应该返回目标资源的主体。</p><h4 id="13-2-2-POST"><a href="#13-2-2-POST" class="headerlink" title="13.2.2. POST"></a>13.2.2. POST</h4><p>服务可以为实体创建启用POST请求。</p><pre class=" language-http"><code class="language-http">POST https://api.contoso.com/v1.0/databases/{  "fileName": "someFile.db",  "color": "red"}</code></pre><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">202 Accepted</span></span><span class="token header-name keyword">Operation-Location:</span> https://api.contoso.com/v1.0/operations/123</code></pre><h4 id="13-2-3-POST-hybrid-model"><a href="#13-2-3-POST-hybrid-model" class="headerlink" title="13.2.3. POST, hybrid model"></a>13.2.3. POST, hybrid model</h4><p>即使在生成响应时未完全创建资源，服务也可以同步响应对创建资源的集合的POST请求。<br>为了使用这种模式，响应必须包括不完整资源的表示以及它不完整的指示。</p><p>例如：</p><pre class=" language-http"><code class="language-http"><span class="token request-line"><span class="token property">POST</span> https://api.contoso.com/v1.0/databases/ HTTP/1.1</span><span class="token header-name keyword">Host:</span> api.contoso.com<span class="token header-name keyword">Content-Type:</span> application/json<span class="token header-name keyword">Accept:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token string">"fileName"</span><span class="token punctuation">:</span> <span class="token string">"someFile.db"</span><span class="token punctuation">,</span>  <span class="token string">"color"</span><span class="token punctuation">:</span> <span class="token string">"red"</span><span class="token punctuation">}</span></span></code></pre><p>服务响应 表示已经创建了数据库，但是通过包含操作位置头表示请求还没有完成。<br>在这种情况下，响应有效负载中的status属性还指示操作尚未完全完成。</p><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">201 Created</span></span><span class="token header-name keyword">Location:</span> https://api.contoso.com/v1.0/databases/db1<span class="token header-name keyword">Operation-Location:</span> https://api.contoso.com/v1.0/operations/123{  "databaseName": "db1",  "color": "red",  "Status": "Provisioning",  [ … other fields for "database" …]}</code></pre><h4 id="13-2-4-Operations-resource"><a href="#13-2-4-Operations-resource" class="headerlink" title="13.2.4. Operations resource"></a>13.2.4. Operations resource</h4><p>服务可以在租户级别提供“/操作”资源。</p><p>提供“/operations”资源的服务 必须提供GET语义。<br>GET必须按照标准的分页、排序和过滤语义枚举一组操作。<br>该操作的默认排序顺序必须是:</p><table><thead><tr><th>Primary Sort</th><th>Secondary Sort</th></tr></thead><tbody><tr><td>Not Started Operations</td><td>Operation Creation Time</td></tr><tr><td>Running Operations</td><td>Operation Creation Time</td></tr><tr><td>Completed Operations</td><td>Operation Creation Time</td></tr></tbody></table><p>注意，“已完成的操作”是一个目标状态(见下文)，并且可能实际上是几个不同状态中的任意一个，比如“成功”、“取消”、“失败”等等。</p><h4 id="13-2-5-Operation-resource"><a href="#13-2-5-Operation-resource" class="headerlink" title="13.2.5. Operation resource"></a>13.2.5. Operation resource</h4><p>操作是一个用户可寻址的资源，它跟踪一个逐步长时间运行的操作。<br>操作必须支持GET语义。<br>针对操作的GET操作必须返回:</p><ol><li>操作资源，它的状态，以及与特定API相关的任何扩展状态。</li><li>200 OK作为响应代码。</li></ol><p>服务可以通过在操作上公开DELETE来支持操作取消。<br>如果支持删除操作，则删除操作必须是幂等的。</p><blockquote><p>注意：从API设计的角度来看，取消并不明确意味着回滚。</p></blockquote><p>在每个API定义的情况下，它可能意味着回滚，补偿，完成或部分完成等。<br>在取消操作后，客户不应将服务返回到允许继续服务的一致状态。</p><p>不支持操作取消的服务必须在DELETE事件中返回405 Method Not Allowed。</p><p>操作必须支持下列状态:</p><ol><li>没有开始(NotStarted)</li><li>运行(Running)</li><li>成功了。终端状态(Succeeded. Terminal State)</li><li>失败了。终端状态(Failed. Terminal State)</li></ol><p>服务可以添加其他状态，例如“已取消”或“部分完成”。 支持取消的服务必须充分描述其取消，以便能够准确地确定系统的状态，并且可以运行任何补偿动作。</p><p>支持其他状态的服务应考虑此规范名称列表，并尽可能避免创建新名称：取消中(Cancelling)，取消(Cancelled)，中止中(Aborting)，中止(Aborted)，逻辑删除(Tombstone)，删除中(Deleting)，删除(Deleted)。</p><p>操作必须包含并在GET响应中提供以下信息:</p><ol><li>创建操作时的时间戳。</li><li>输入当前状态的时间戳。</li><li>操作状态(未启动/运行/完成)。</li></ol><p>服务可以向操作中添加附加的特定于API的字段。<br>返回的操作状态JSON如下:</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"createdDateTime"</span><span class="token operator">:</span> <span class="token string">"2015-06-19T12-01-03.45Z"</span><span class="token punctuation">,</span>  <span class="token property">"lastActionDateTime"</span><span class="token operator">:</span> <span class="token string">"2015-06-19T12-01-03.45Z"</span><span class="token punctuation">,</span>  <span class="token property">"status"</span><span class="token operator">:</span> "notstarted | running | succeeded | failed"<span class="token punctuation">}</span></code></pre><h5 id="Percent-complete"><a href="#Percent-complete" class="headerlink" title="Percent complete"></a>Percent complete</h5><p>有时，服务不可能准确地知道操作何时完成。<br>这使得使用回车后标头有问题。<br>在这种情况下，服务可能在operationStatus JSON中包含一个百分比完成字段。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"createdDateTime"</span><span class="token operator">:</span> <span class="token string">"2015-06-19T12-01-03.45Z"</span><span class="token punctuation">,</span>  <span class="token property">"percentComplete"</span><span class="token operator">:</span> <span class="token string">"50"</span><span class="token punctuation">,</span>  <span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"running"</span><span class="token punctuation">}</span></code></pre><p>在本例中，服务器向客户机表明，长时间运行的操作已经完成了50%。</p><h5 id="Target-resource-location"><a href="#Target-resource-location" class="headerlink" title="Target resource location"></a>Target resource location</h5><p>对于导致或操作资源的操作，服务必须在操作完成时将目标资源位置包含在状态中。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"createdDateTime"</span><span class="token operator">:</span> <span class="token string">"2015-06-19T12-01-03.45Z"</span><span class="token punctuation">,</span>  <span class="token property">"lastActionDateTime"</span><span class="token operator">:</span> <span class="token string">"2015-06-19T12-06-03.0024Z"</span><span class="token punctuation">,</span>  <span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"succeeded"</span><span class="token punctuation">,</span>  <span class="token property">"resourceLocation"</span><span class="token operator">:</span> <span class="token string">"https://api.contoso.com/v1.0/databases/db1"</span><span class="token punctuation">}</span></code></pre><h4 id="13-2-6-Operation-tombstones"><a href="#13-2-6-Operation-tombstones" class="headerlink" title="13.2.6. Operation tombstones"></a>13.2.6. Operation tombstones</h4><p>服务可以选择支持逻辑删除操作。<br>服务可以选择在服务定义的时间段之后删除tombstone。</p><h4 id="13-2-7-The-typical-flow-polling"><a href="#13-2-7-The-typical-flow-polling" class="headerlink" title="13.2.7. The typical flow, polling"></a>13.2.7. The typical flow, polling</h4><ul><li>Client通过使用POST调用来分阶段操作</li><li>服务器必须通过使用 202 Accepted 状态码来响应请求，从而表明该请求已经启动。响应应该包括包含URL的位置标头，客户端应该在等待 Retry-After 标头中指定的秒数后轮询结果。</li><li>客户端轮询该位置，直到收到具有终端操作状态的200响应。</li></ul><h5 id="Example-of-the-typical-flow-polling"><a href="#Example-of-the-typical-flow-polling" class="headerlink" title="Example of the typical flow, polling"></a>Example of the typical flow, polling</h5><p>客户端重启调用动作：</p><pre class=" language-http"><code class="language-http"><span class="token request-line"><span class="token property">POST</span> https://api.contoso.com/v1.0/databases HTTP/1.1</span><span class="token header-name keyword">Accept:</span> application/json{  "fromFile": "myFile.db",  "color": "red"}</code></pre><p>服务器响应表明已创建请求。</p><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">202 Accepted</span></span><span class="token header-name keyword">Operation-Location:</span> https://api.contoso.com/v1.0/operations/123</code></pre><p>客户端等待一段时间然后调用另一个请求以尝试获取操作状态。</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/operations/123<span class="token header-name keyword">Accept:</span> application/json</code></pre><p>服务器响应结果仍未准备好，并提供等待30秒的建议(可选操作)。</p><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Retry-After:</span> 30{  "createdDateTime": "2015-06-19T12-01-03.4Z",  "status": "running"}</code></pre><p>客户端等待建议的30秒，然后调用另一个请求以获取操作结果。</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/v1.0/operations/123<span class="token header-name keyword">Accept:</span> application/json</code></pre><p>服务器以包含资源位置的“状态：成功”操作进行响应。</p><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token string">"createdDateTime"</span><span class="token punctuation">:</span> <span class="token string">"2015-06-19T12-01-03.45Z"</span><span class="token punctuation">,</span>  <span class="token string">"lastActionDateTime"</span><span class="token punctuation">:</span> <span class="token string">"2015-06-19T12-06-03.0024Z"</span><span class="token punctuation">,</span>  <span class="token string">"status"</span><span class="token punctuation">:</span> <span class="token string">"succeeded"</span><span class="token punctuation">,</span>  <span class="token string">"resourceLocation"</span><span class="token punctuation">:</span> <span class="token string">"https://api.contoso.com/v1.0/databases/db1"</span><span class="token punctuation">}</span></span></code></pre><h4 id="13-2-8-The-typical-flow-push-notifications"><a href="#13-2-8-The-typical-flow-push-notifications" class="headerlink" title="13.2.8. The typical flow, push notifications"></a>13.2.8. The typical flow, push notifications</h4><p>1.客户端通过使用POST调用操作来调用长时间运行的操作。 客户端已在父资源上设置了推送通知。<br>2.服务通过响应202 Accepted状态代码表示请求已启动。 客户忽略了其他一切。<br>3.完成整个操作后，服务通过父资源上的订阅推送通知。<br>4.客户端通过资源URL检索操作结果。</p><h5 id="Example-of-the-typical-flow-push-notifications-existing-subscription"><a href="#Example-of-the-typical-flow-push-notifications-existing-subscription" class="headerlink" title="Example of the typical flow, push notifications existing subscription"></a>Example of the typical flow, push notifications existing subscription</h5><p>客户端调用备份操作。<br>客户端已经为db1提供了推送通知订阅设置。</p><pre class=" language-http"><code class="language-http"><span class="token request-line"><span class="token property">POST</span> https://api.contoso.com/v1.0/databases/db1?backup HTTP/1.1</span><span class="token header-name keyword">Accept:</span> application/json</code></pre><p>服务器响应表明该请求已被接受。</p><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">202 Accepted</span></span><span class="token header-name keyword">Operation-Location:</span> https://api.contoso.com/v1.0/operations/123</code></pre><p>调用者忽略返回中的所有标头。</p><p>操作完成后，目标URL会收到推送通知。</p><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token string">"value"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token string">"subscriptionId"</span><span class="token punctuation">:</span> <span class="token string">"1234-5678-1111-2222"</span><span class="token punctuation">,</span>      <span class="token string">"context"</span><span class="token punctuation">:</span> <span class="token string">"subscription context that was specified at setup"</span><span class="token punctuation">,</span>      <span class="token string">"resourceUrl"</span><span class="token punctuation">:</span> <span class="token string">"https://api.contoso.com/v1.0/databases/db1"</span><span class="token punctuation">,</span>      <span class="token string">"userId"</span> <span class="token punctuation">:</span> <span class="token string">"contoso.com/user@contoso.com"</span><span class="token punctuation">,</span>      <span class="token string">"tenantId"</span> <span class="token punctuation">:</span> <span class="token string">"contoso.com"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></span></code></pre><h4 id="13-2-9-Retry-After"><a href="#13-2-9-Retry-After" class="headerlink" title="13.2.9. Retry-After"></a>13.2.9. Retry-After</h4><p>在上面的示例中，Retry-After标头指示客户端在尝试从位置标头标识的URL获取结果之前应等待的秒数。</p><p>HTTP规范允许Retry-After头指定HTTP日期，因此客户端也应该准备好处理这个问题。</p><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">202 Accepted</span></span><span class="token header-name keyword">Operation-Location:</span> http://api.contoso.com/v1.0/operations/123<span class="token header-name keyword">Retry-After:</span> 60</code></pre><p>注意:HTTP日期的使用与本文档中使用的ISO 8601日期格式不一致，但是由[RFC 7231][RFC -7231-7-1-1-1]中的HTTP标准明确定义。服务应该选择整数秒(十进制)格式，而不是HTTP日期格式。</p><h3 id="13-3-Retention-policy-for-operation-results"><a href="#13-3-Retention-policy-for-operation-results" class="headerlink" title="13.3. Retention policy for operation results"></a>13.3. Retention policy for operation results</h3><p>在某些情况下，长时间运行操作的结果不是可以处理的资源。<br>例如，如果您调用一个返回布尔值(而不是资源)的长时间运行的操作。<br>在这些情况下，Location头指向可以检索布尔结果的位置。</p><p>这就引出了一个问题:“运行的结果应该保留多久?”</p><p>建议的最短保留时间为24小时。</p><p>在从系统中清除之前，操作应该再过渡到墓碑(tombstone)一段时间。</p><h2 id="14-限流-配额-和限定"><a href="#14-限流-配额-和限定" class="headerlink" title="14. 限流, 配额, 和限定"></a>14. 限流, 配额, 和限定</h2><h3 id="14-1-原则"><a href="#14-1-原则" class="headerlink" title="14.1. 原则"></a>14.1. 原则</h3><p>服务应该尽可能地响应调用，以免阻塞调用者。</p><p>根据经验，任何预计在完成最后1%上花费超过0.5秒的API调用 都应该考虑对这些调用使用长时间运行操作模式。</p><p>显然，面对来自调用方的潜在的无限负载，服务必然面临无法保证这些响应时间。因此，服务应该为客户端设计和记录调用请求限制，并在超过这些限制时使用适当的、可操作的错误和错误消息进行响应。</p><p>当服务通常过载时，它们应该快速响应错误，而不是简单不去处理导致响应缓慢。<br>最后，许多服务将对调用设置有配额，可能是每小时或每天的操作数，通常与服务计划或价格相关。<br>当超过这些配额时，服务还必须提供即时的、可操作的错误。<br>配额和限制的范围应该限定到一个客户单元:订阅、租户、应用程序、计划，或者在没有任何其他标识的情况下，根据服务目标确定一系列ip地址……以便正确地共享负载，并且一个单元不会干扰另一个单元。</p><h3 id="14-2-返回HTTP代码-429-vs-503"><a href="#14-2-返回HTTP代码-429-vs-503" class="headerlink" title="14.2. 返回HTTP代码 (429 vs 503)"></a>14.2. 返回HTTP代码 (429 vs 503)</h3><p>HTTP为这些场景指定了两个返回代码:“429 Too Many Requests”和“503 Service Unavailable”。<br>服务应该返回 429 来处理客户端调用数过多的情况，并且可以通过更改调用模式来修复这种情况。<br>如果一般负载或个别调用者无法控制的其他问题导致服务变慢，则服务应使用503进行响应。</p><p>在这种情况下，服务还应该提供信息，建议调用者在再次尝试之前应该等待多长时间。<br>客户端应该尊重服务器返回的这些报头，并实现其他瞬时故障处理技术。<br>然而，可能有一些客户端在失败后立即重试，这可能会增加服务的负载。<br>为了处理这个问题，服务的设计应该使返回429或503尽可能不那么消耗服务资源(便宜)，要么输入特殊的快速路径代码，要么理想情况下依赖于提供此功能的公共网管或负载均衡器。</p><h3 id="14-3-稍后重试-Retry-After-和-限制速度标头-RateLimit-Headers"><a href="#14-3-稍后重试-Retry-After-和-限制速度标头-RateLimit-Headers" class="headerlink" title="14.3. 稍后重试(Retry-After) 和 限制速度标头(RateLimit Headers)"></a>14.3. 稍后重试(Retry-After) 和 限制速度标头(RateLimit Headers)</h3><p>Retry-After报头是响应正在限流的客户端的标准方法。<br>在限制和配额(但不是整个系统负载)的情况下，使用描述超出限制的头部来响应也是常见的，但也是可选的。<br>然而，微软和整个行业的服务为此目的使用了各种不同的头文件。<br>我们建议使用三个头来描述限制、限制下剩余的调用数量以及限制将重置的时间。<br>但是，其他头可能适合特定类型的限制。不管什么情况下，这些都必须记录下来。</p><h3 id="14-4-服务端指南"><a href="#14-4-服务端指南" class="headerlink" title="14.4. 服务端指南"></a>14.4. 服务端指南</h3><p>服务应根据SLA或业务目标选择适合的时间窗口。<br>在配额的情况下，Retry-After时间和时间窗口可能很长（小时，天，周，甚至几个月。服务使用429表示特定的调用者发出了太多的调用，使用503表示服务正在减少负载，但这不是调用者的责任。</p><h4 id="14-4-1-响应性"><a href="#14-4-1-响应性" class="headerlink" title="14.4.1. 响应性"></a>14.4.1. 响应性</h4><ol><li>服务必须在所有情况下快速响应，即使在负载过多的情况下也是如此。</li><li>如果该调用99%响应花费超过1秒应该使用长时间运行模式。</li><li>如果该调用99％的响应持续时间超过0.5秒中应该强烈考虑LRO模式。</li><li>服务不应该引入阻塞调用者或不可操作的睡眠、暂停等(“tar-pitting”)。</li></ol><h4 id="14-4-2-限速和配额"><a href="#14-4-2-限速和配额" class="headerlink" title="14.4.2. 限速和配额"></a>14.4.2. 限速和配额</h4><p>当呼叫者过多调用（可能是滥用）</p><p>1.服务必须返回429代码<br>2.服务必须返回描述细节的标准错误响应，以便程序员可以进行适当的更改<br>3.服务必须返回一个Retry-After标头，指示客户端在重试之前应该等待多长时间<br>4.服务可以返回RateLimit标题，用于记录已超出的限制或配额<br>5.服务可以返回RateLimit-Limit：客户端允许在时间窗口中进行的调用次数<br>6.服务可以返回RateLimit-Remaining：时间窗口中剩余的调用数量<br>7.服务可能返回RateLimit-Reset:窗口重置的时间，以UTC格式 秒为单位<br>8.服务可以根据需要返回其他特定于服务的RateLimit标头，以获取更多详细信息或特定限制或配额</p><h4 id="14-4-3-服务过载"><a href="#14-4-3-服务过载" class="headerlink" title="14.4.3. 服务过载"></a>14.4.3. 服务过载</h4><p>当服务通常过载和减载时<br>1.服务必须返回一个503代码<br>2.服务必须返回一个描述细节的标准错误响应(参见7.10.2)，以便程序员能够做出适当的更改<br>3.服务必须返回一个Retry-After头文件，该头文件指示客户机在重试之前应该等待多长时间<br>4.在503情况下，服务不应该返回RateLimit报头</p><h4 id="14-4-4-响应的例子"><a href="#14-4-4-响应的例子" class="headerlink" title="14.4.4. 响应的例子"></a>14.4.4. 响应的例子</h4><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">429 Too Many Requests</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token header-name keyword">Retry-After:</span> 5<span class="token header-name keyword">RateLimit-Limit:</span> 1000<span class="token header-name keyword">RateLimit-Remaining:</span> 0<span class="token header-name keyword">RateLimit-Reset:</span> 1538152773{  "error": {    "code": "requestLimitExceeded",    "message": "The caller has made too many requests in the time period.",    "details": {      "code": "RateLimit",       "limit": "1000",       "remaining": "0",       "reset": "1538152773",      }    }}</code></pre><h3 id="14-5-客户端指南"><a href="#14-5-客户端指南" class="headerlink" title="14.5. 客户端指南"></a>14.5. 客户端指南</h3><p>调用者包括API的所有用户:工具、门户、其他服务，而不仅仅是用户客户端</p><ol><li>在重试请求之前，调用者必须等待Retry-After响应中指示的最短时间。</li><li>调用者可以假设，在接收到带有Retry-After标头的响应之后，再重试请求，而不需要对请求做任何更改。</li><li>客户端应该使用共享的sdk和通用的瞬态故障库来实现正确的行为</li></ol><p>See: <a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/transient-faults" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/architecture/best-practices/transient-faults</a></p><h3 id="14-6-处理调用忽略Retry-After标头"><a href="#14-6-处理调用忽略Retry-After标头" class="headerlink" title="14.6. 处理调用忽略Retry-After标头"></a>14.6. 处理调用忽略Retry-After标头</h3><p>理想情况下，429和503返回的成本非常低，甚至可以处理大量立即重试的客户端请求。<br>在这些情况下，如果可能，服务团队应该努力联系或修复客户端。<br>如果是已知合作伙伴，则应提交错误或事件。<br>在极端情况下，可能需要采用DoS攻击保护，例如阻止调用者。</p><h2 id="15-通过-webhooks-推送通知"><a href="#15-通过-webhooks-推送通知" class="headerlink" title="15. 通过 webhooks 推送通知"></a>15. 通过 webhooks 推送通知</h2><h3 id="15-1-范围"><a href="#15-1-范围" class="headerlink" title="15.1. 范围"></a>15.1. 范围</h3><p>服务可以通过Web钩子（Hooks)实现推送通知。<br>本节介绍以下关键方案：</p><blockquote><p>通过HTTP回调（通常称为Web Hooks）将通知推送到可公开寻址的服务器。</p></blockquote><p>之所以选择这种方法，是因为它简单、适用范围广，并且对服务订阅者的进入门槛很低。<br>它旨在作为一组最低要求，并作为其他功能的起点。</p><h3 id="15-2-原则"><a href="#15-2-原则" class="headerlink" title="15.2. 原则"></a>15.2. 原则</h3><p>支持Web钩子的服务的核心原则是：</p><ol><li>服务必须实现至少一个戳/拉模型。在poke/pull模型中，通知被发送给客户端，然后客户端发送一个请求来获取自上次通知以来的当前状态或更改记录。这种方法避免了消息排序，错过消息和变更集的复杂性。服务可以添加更多的数据来提供丰富的通知。</li><li>服务必须实现用于配置回调url的质询/响应协议。</li><li>服务应该有建议的过期时间，服务可以根据场景灵活地变化。</li><li>服务应该允许那些发出成功通知的订阅永久存在，并且应该容忍合理的停机时间。</li><li>Firehose 订阅只能通过 HTTPS 提供。服务应要求其他订阅类型为HTTPS。有关详细信息，请参阅“安全性”部分。</li></ol><h3 id="15-3-订阅类型"><a href="#15-3-订阅类型" class="headerlink" title="15.3. 订阅类型"></a>15.3. 订阅类型</h3><p>有两种订阅类型，服务可以实现，或者两者都可以。<br>支持的订阅类型包括：</p><ol><li>Firehose订阅 - 为订阅应用程序手动创建订阅，通常在应用程序注册门户中。 任何用户同意接收应用的活动通知都会发送到此单个订阅。</li><li>每个资源订阅 - 订阅应用程序使用代码以编程方式在运行时为某些特定于用户的实体创建订阅。</li></ol><p>支持这两种订阅类型的服务应该为这两种类型提供不同的开发人员体验:</p><ol><li>Firehose - 服务必须不要求开发人员创建代码，除非直接验证和响应通知。服务必须为订阅管理提供管理UI。服务不应该假设最终用户知道订阅，只知道订阅应用程序的功能。</li><li>每个用户 - 服务必须为开发人员提供API，以便在他们的应用程序中创建和管理订阅，以及验证和响应通知。 服务可能希望最终用户了解订阅，并且必须允许最终用户撤销在响应用户操作时直接创建订阅的订阅。</li></ol><h3 id="15-4-调用序列"><a href="#15-4-调用序列" class="headerlink" title="15.4. 调用序列"></a>15.4. 调用序列</h3><p>Firehose订阅的调用顺序必须遵循下图。<br>它显示了应用程序和订阅的手动注册，然后是最终用户使用其中一个服务的API。<br>在这部分流程中，必须存储两件事：</p><ol><li>服务必须存储最终用户同意接收来自此特定应用程序的通知的行为(通常是后台使用OAUTH范围)。</li><li>订阅应用程序必须存储最终用户的令牌，以便在收到更改通知后回调详细信息。</li></ol><p>序列的最后一部分是通知流本身。</p><p>非规范实现指导:服务中的资源发生变化，服务需要运行以下逻辑:</p><ol><li>确定有权访问该资源的用户集，因此可能希望应用程序代表他们接收有关该资源的通知。</li><li>查看哪些用户已同意接收通知以及从哪些应用收到通知。</li><li>查看哪些应用已注册firehose订阅。</li><li>加入1,2,3以生成必须发送到应用程序的具体通知集。</li></ol><p>应该注意的是，用户同意的行为和建立firehose订阅的行为可以以任何顺序到达。<br>服务应该发送通知，并以任何顺序处理设置。</p><p><img src="http://www.websequencediagrams.com/cgi-bin/cdraw?lz=bm90ZSBvdmVyIERldmVsb3BlciwgQXV0b21hdGlvbiwgQXBwIFNlcnZlcjogCiAgICAgQW4AEAUAJwkgbGlrZSBNb3ZpZU1ha2VyACAGV2FudHMgdG8gaW50ZWdyYXRlIHdpdGggcHJpbWFyeSBzZXJ2aWNlADcGRHJvcGJveAplbmQgbm90ZQoAgQwLQiBQb3J0YWwsIERCAIEJBVJlZ2lzdHIAgRkHREIgTm90aWZpYwCBLAVzACEGdXRoACsFUwBgBjogVGhlAF0eAIF_CkNsaWVudAAtBmVuZCB1c2VycycgYnJvd3NlciBvciBpbnN0YWxsZWQgYXBwCgCBIQwAgiQgAIFABQCBIS8AgQoGIDogTWFudWFsAIFzEQoKCgCDAgo8LS0-AIIqCiA6IExvZ2luIGludG8Agj8JAII1ECBVWCAKACoKLT4gKwCCWBM6AIQGBU5hbWUgZXRjLgCDFQ4AGxJDb25maXJtAIEBCEFjY2VzcyBUb2tlbgoKAIM3EyAtPiAtAINkCQBnBklEAIEMCwCBVQUAhQIMAIR3CmNvcGllcwArCACCIHAAhHMMAIMKDwCDABg6IHdlYmhvb2sgcgCCeg4AgnUSAIVQDToAhXYHZXIAgwgGAIcTBgBECVVSTCwgU2NvcGUAhzIGSUQKTgCGPQwAhhwNIACDBh4AHhEAgxEPbgCBagwAgxwNAIMaDiAAgx0MbWF5IGNvcHkALREAhVtqAIZHB0F1dGhvcml6AIY7BwCGXQctPiArAIEuDVJlcXVlc3QgYQCFOQZ0byBEQiBwcm90ZWN0ZWQgaW5mb3IAiiQGCgCDBQstPiAtAIctCVJlZGlyZWN0ADYHAGwNIGVuZHBvaW50AIoWBmEADw1yAHYGAIEQDACJVAcASwtlZAAYHgCICAgAMAcAcA4AhGoGAE0FAIEdFmJhY2sgdG8AhF8NaXRoIGNvZGUAghoaaQCBagcAgToHAD0JAII-B3MAPgsAglEHAEsFAIIzDgCBXw0Agn8GdG9rZW5zACcSAI0_BXJpZ2h0IG9mAItpDUNhY2hlIHRoYXQgdGhpcyBVc2VyIElEIHByb3ZpZGVkAINNCwCIZgoAggcJAIN7D3Nwb25zAI0_BwCECgYsIHJlZnJlc2gsIGFuZCBJRACBHAcAgQMPAIYADQCBDAcAgUUGYnkAjFkFIElEAIQkG3R1cm4AhF4MIHRvIGMAjR8FAIwRagCJVw1GbG93AIYqCQCMaQgAgmoKaGFuZ2UAj3YFAIFXBWRhdGEgLSB0eXBpY2FsIHZpYQCQDgVyYWN0aW5nAJAPBgCJQQt2aWEAjnsHCgCPNgogAIhDEACKZw0AkFMFAIkBDwCDDAUAgkYWKwBNCwCHWApjAIEyBQCHRg0AhWUHYWNoAIQeDACEfwVhbmQgInNpbmNlIgCFEQYAkSQOAIR3CgCNfwcAhHQFAIpQEACBUgsAhFAcAII8BWFuZCBuZXcAYRQAhFUTOiBVcGRhdGUgc3RhdHUAgSkGAIFDBQAxEwoKCg&s=mscgen" alt="Firehose subscription setup"></p><p>对于每用户订阅，应用程序注册是手动或自动的。<br>每用户订阅的呼叫流程必须遵循下图。<br>它显示了最终用户使用其中一个服务的API，同样，必须存储相同的两件事：</p><p>1.服务必须存储最终用户同意接收来自此特定应用程序的通知的行为（通常是后台使用OAUTH范围）。<br>2.订阅应用程序必须存储最终用户的令牌，以便在收到更改通知后回拨详细信息。</p><p>在这种情况下，使用订阅应用程序中的最终用户令牌以编程方式设置订阅。<br>应用程序必须与用户令牌一起存储已注册订阅的ID。</p><p>非规范性实施指南：在序列的最后部分，当服务中的数据项发生更改且服务需要运行以下逻辑时：</p><p>1.找到通过资源与更改的数据对应的订阅集。<br>2.对于在app +用户令牌下创建的订阅，使用订阅ID和订阅创建者的用户ID向每个订阅的应用发送通知。</p><ul><li>对于使用仅限应用程序令牌创建的订阅，请检查已更改数据的所有者或已更改数据可见性的任何用户是否已同意向应用程序发送通知，如果是，则将每个用户ID的一组通知发送给应用程序 每个订阅使用订阅ID。</li></ul><p><img src="http://www.websequencediagrams.com/cgi-bin/cdraw?lz=bm90ZSBvdmVyIERldmVsb3BlciwgQXV0b21hdGlvbiwgQXBwIFNlcnZlcjogCiAgICAgQW4AEAUAJwkgbGlrZSBNb3ZpZU1ha2VyACAGV2FudHMgdG8gaW50ZWdyYXRlIHdpdGggcHJpbWFyeSBzZXJ2aWNlADcGRHJvcGJveAplbmQgbm90ZQoAgQwLQiBQb3J0YWwsIERCAIEJBVJlZ2lzdHIAgRkHREIgTm90aWZpYwCBLAVzACEGdXRoACsFUwBgBjogVGhlAF0eAIF_CkNsaWVudAAtBmVuZCB1c2VycycgYnJvd3NlciBvciBpbnN0YWxsZWQgYXBwCgCBIQwAgiQgAIFABQCBIS8AgQoGIDoAgWwRCgphbHQAgyUIAIEHBiByABQMICAAgxsLPC0tPgCDTws6IENvbmZpZ3VyZQogIACDaAsgLT4gKwCCWBMAegZOYW1lIGV0Yy4AhAgFAIMaDQAfEgBdBXJtAIQ_BUFjY2VzcyBUb2tlAIETBgCDOxIgLT4gLQCBFgxBcHAgSUQAhHwIY3JldACBGxAtPgCFFgsgOiBFbWJlZAAkFGVsc2UgTWFudWFsAIIEJACEbQkgOiBMb2dpbiBpbnRvAIUBCQCBKRFVWACGGAUALQoAgh8mAIIZKwCBCAcAgjoNAIIsHACGLwkAgj8IAIESDgCECAYAh1ELAIdFCmNvcGllcwAuCGVuZACEeGoAhWQHQXV0aG9yaXoAhV8HAIV6By0-ICsAg2ANUmVxdWVzdCBhAIRVBnRvIERCIHByb3RlY3RlZCBpbmZvcgCJQQYKAIQaCy0-IC0AhkoJUmVkaXJlY3QANgcAbA0gZW5kcG9pbnQAiTMGYQAPDXIAdgYAgRAMAIhxBwBLC2VkABgeAIRjCAAwB0EAcQxVWAoASQgAgRwWYmFjayB0bwCFdAwAilwFY29kZQCCGRppAIFpBwCBOQcAPQkAgj0HcwA-CwCCUAcASwUAgjIOAIFeDQCCfgZ0b2tlbnMAJxIAjFsFcmlnaHQgb2YAiwUNQ2FjaGUgdGhhdCB0aGlzIFVzZXIgSUQgcHJvdmlkZWQAg0wLAIU6BwCCBAwAg3oPc3BvbnMAjFsHAIQJBiwgcmVmcmVzaCwgYW5kIElEAIEcBwCBAw8AiDENAIEMBwCBRQZieQCLdQUgSUQAhCMbdHVybgCEXQwgdG8gYwCMOwUKCgCLL2oAjXUMAIwTDwCPNQotPisAjhwQOgCORQdlcgCMVwYAg3YIZWJob29rIFVSTCwgU2NvcGUAkAEGSUQAjwoOAI5rDSAAi2UKAINFBQCLYw0AHBEAgzUOOiBuAIE2DABgCACDCB1oZQCBaQ5JRACDYwUAahIAghB4RmxvdwCJMwkAjE0IAIV0CmhhbmdlAJIcBQCEYQVkYXRhIC0gdHlwaWNhbCB2aWEAkjQFcmFjdGluZwCSNQYAjV8LdmlhAJEhBwoAkVwKIACNfhAAhAsNAJJ5BQCCWQ8AhhYFAIVQFisATQsAimEKYwCBMgUAik8NAIhvB2FjaACHKAwAiAkFYW5kICJzaW5jZSIAiBsGAJNKDgCIAQoAhB0cAIFSCwCHWhwAgjwFYW5kIG5ldwBhFACHXxM6IFVwZGF0ZSBzdGF0dQCBKQYAgUMFADETCgoK&s=mscgen" alt="User subscription setup"></p><h3 id="15-5-Verifying-subscriptions"><a href="#15-5-Verifying-subscriptions" class="headerlink" title="15.5. Verifying subscriptions"></a>15.5. Verifying subscriptions</h3><p>当订阅以编程方式更改或通过管理UI门户更改响应时，需要保护订阅服务免受来自可能导致大量通知流量的服务的恶意或意外调用。</p><p>对于所有订阅，无论是firehose还是每用户，服务必须在发送任何其他通知之前，通过门户网站UI或API请求作为创建或修改的一部分发送验证请求。</p><p>验证请求必须具有以下格式作为订阅的_notificationUrl_的HTTP/HTTPS POST。</p><pre class=" language-http"><code class="language-http">POST https://{notificationUrl}?validationToken={randomString}<span class="token header-name keyword">ClientState:</span> clientOriginatedOpaqueToken (if provided by client on subscription-creation)<span class="token header-name keyword">Content-Length:</span> 0</code></pre><p>对于要设置的订阅，应用程序必须以200 OK对此请求进行响应，并将_validationToken_值作为唯一的实体主体。<br>请注意，如果_notificationUrl_包含查询参数，则_validationToken_参数必须附加“＆”。</p><p>如果任何质询请求在发送请求后的5秒内没有收到规定的响应，则服务必须返回错误，不得创建订阅，并且不得向_notificationUrl_发送更多请求或通知。</p><p>服务可以对URL所有权执行其他验证。</p><h3 id="15-6-Receiving-notifications"><a href="#15-6-Receiving-notifications" class="headerlink" title="15.6. Receiving notifications"></a>15.6. Receiving notifications</h3><p>服务应该发送通知以响应服务数据更改，这些更改不包括更改本身的详细信息，但包含足够的信息以供订阅应用程序适当地响应以下过程：</p><ol><li>应用程序必须识别用于回调的正确缓存OAuth令牌</li><li>应用程序可以查找任何先前的delta令牌以获取相关的更改范围</li><li>应用程序必须确定要调用的URL以执行服务的新状态的相关查询，该查询可以是增量查询。</li></ol><p>提供将被转发给最终用户的通知的服务可以选择向通知包添加更多细节，以减少其服务上的呼入负载。<br>此类服务必须清楚，通知不能保证交付，可能有损或无序。</p><p>通知可以聚合并分批发送。<br>应用程序必须准备好在单个推送通知中接收多个事件。</p><p>服务必须发送所有Web Hook数据通知作为POST请求。</p><p>服务必须允许30秒的通知超时。<br>如果发生超时或应用程序以5xx响应响应，则服务应该以指数退避重试通知。<br>所有其他回复都将被忽略。</p><p>该服务不得遵循301/302重定向请求。</p><h4 id="15-6-1-Notification-payload"><a href="#15-6-1-Notification-payload" class="headerlink" title="15.6.1. Notification payload"></a>15.6.1. Notification payload</h4><p>通知有效负载的基本格式是事件列表，每个事件包含其引用资源已更改的订阅的ID，更改类型，用于标识更改的确切详细信息以及要查看的足够标识信息所应消耗的资源 调用该资源所需的令牌。</p><p>对于firehose订阅，这个具体的例子可能如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"value"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"subscriptionId"</span><span class="token operator">:</span> <span class="token string">"32b8cbd6174ab18b"</span><span class="token punctuation">,</span>      <span class="token property">"resource"</span><span class="token operator">:</span> <span class="token string">"https://api.contoso.com/v1.0/users/user@contoso.com/files?$delta"</span><span class="token punctuation">,</span>      <span class="token property">"userId"</span> <span class="token operator">:</span> <span class="token string">"&lt;User GUID>"</span><span class="token punctuation">,</span>      <span class="token property">"tenantId"</span> <span class="token operator">:</span> <span class="token string">"&lt;Tenant Id>"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>对于每用户订阅，具体示例可能如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"value"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"subscriptionId"</span><span class="token operator">:</span> <span class="token string">"32b8cbd6174ab183"</span><span class="token punctuation">,</span>      <span class="token property">"clientState"</span><span class="token operator">:</span> <span class="token string">"clientOriginatedOpaqueToken"</span><span class="token punctuation">,</span>      <span class="token property">"expirationDateTime"</span><span class="token operator">:</span> <span class="token string">"2016-02-04T11:23Z"</span><span class="token punctuation">,</span>      <span class="token property">"resource"</span><span class="token operator">:</span> <span class="token string">"https://api.contoso.com/v1.0/users/user@contoso.com/files/$delta"</span><span class="token punctuation">,</span>      <span class="token property">"userId"</span> <span class="token operator">:</span> <span class="token string">"&lt;User GUID>"</span><span class="token punctuation">,</span>      <span class="token property">"tenantId"</span> <span class="token operator">:</span> <span class="token string">"&lt;Tenant Id>"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"subscriptionId"</span><span class="token operator">:</span> <span class="token string">"97b391179fa22"</span><span class="token punctuation">,</span>      <span class="token property">"clientState "</span><span class="token operator">:</span> <span class="token string">"clientOriginatedOpaqueToken"</span><span class="token punctuation">,</span>      <span class="token property">"expirationDateTime"</span><span class="token operator">:</span> <span class="token string">"2016-02-04T11:23Z"</span><span class="token punctuation">,</span>      <span class="token property">"resource"</span><span class="token operator">:</span> <span class="token string">"https://api.contoso.com/v1.0/users/user@contoso.com/files/$delta"</span><span class="token punctuation">,</span>      <span class="token property">"userId"</span> <span class="token operator">:</span> <span class="token string">"&lt;User GUID>"</span><span class="token punctuation">,</span>      <span class="token property">"tenantId"</span> <span class="token operator">:</span> <span class="token string">"&lt;Tenant Id>"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>以下是JSON有效负载的详细说明。</p><p>通知项目包含一个顶级对象，该对象包含一系列事件，每个事件都标识了此通知发送的订阅。</p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>value</td><td>Array of events that have been raised within the subscription’s scope since the last notification.</td></tr></tbody></table><p>Each item of the events array contains the following properties:</p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>subscriptionId</td><td>The id of the subscription due to which this notification has been sent.<br>Services MUST provide the <em>subscriptionId</em> field.</td></tr><tr><td>clientState</td><td>Services MUST provide the <em>clientState</em> field if it was provided at subscription creation time.</td></tr><tr><td>expirationDateTime</td><td>Services MUST provide the <em>expirationDateTime</em> field if the subscription has one.</td></tr><tr><td>resource</td><td>Services MUST provide the resource field. This URL MUST be considered opaque by the subscribing application.  In the case of a richer notification it MAY be subsumed by message content that implicitly contains the resource URL to avoid duplication.<br>If a service is providing this data as part of a more detailed data packet, then it need not be duplicated.</td></tr><tr><td>userId</td><td>Services MUST provide this field for user-scoped resources.  In the case of user-scoped resources, the unique identifier for the user should be used.<br>In the case of resources shared between a specific set of users, multiple notifications must be sent, passing the unique identifier of each user.<br>For tenant-scoped resources, the user id of the subscription should be used.</td></tr><tr><td>tenantId</td><td>Services that wish to support cross-tenant requests SHOULD provide this field. Services that provide notifications on tenant-scoped data MUST send this field.</td></tr></tbody></table><h3 id="15-7-Managing-subscriptions-programmatically"><a href="#15-7-Managing-subscriptions-programmatically" class="headerlink" title="15.7. Managing subscriptions programmatically"></a>15.7. Managing subscriptions programmatically</h3><p>对于每用户订阅，必须提供API来创建和管理订阅。<br>API必须至少支持此处描述的操作。</p><h4 id="15-7-1-Creating-subscriptions"><a href="#15-7-1-Creating-subscriptions" class="headerlink" title="15.7.1. Creating subscriptions"></a>15.7.1. Creating subscriptions</h4><p>客户端通过针对订阅资源发出POST请求来创建订阅。<br>订阅命名空间是通过POST操作进行客户端定义的。</p><pre><code>https://api.contoso.com/apiVersion/$subscriptions</code></pre><p>POST请求包含要创建的单个订阅对象。<br>该订阅对象具有以下属性：</p><table><thead><tr><th>Property Name</th><th>Required</th><th>Notes</th></tr></thead><tbody><tr><td>resource</td><td>Yes</td><td>Resource path to watch.</td></tr><tr><td>notificationUrl</td><td>Yes</td><td>The target web hook URL.</td></tr><tr><td>clientState</td><td>No</td><td>Opaque string passed back to the client on all notifications. Callers may choose to use this to provide tagging mechanisms.</td></tr></tbody></table><p>如果订阅已成功创建，则服务必须以状态代码201 CREATED和包含至少以下属性的正文进行响应：</p><table><thead><tr><th>Property Name</th><th>Required</th><th>Notes</th></tr></thead><tbody><tr><td>id</td><td>Yes</td><td>Unique ID of the new subscription that can be used later to update/delete the subscription.</td></tr><tr><td>expirationDateTime</td><td>No</td><td>Uses existing Microsoft REST API Guidelines defined time formats.</td></tr></tbody></table><p>订阅的创建应该是幂等的。<br>限定为auth令牌的属性组合提供唯一性约束。</p><p>下面是使用User + Application主体订阅文件通知的示例请求：</p><pre class=" language-http"><code class="language-http">POST https://api.contoso.com/files/v1.0/$subscriptions HTTP 1.1<span class="token header-name keyword">Authorization:</span> Bearer {UserPrincipalBearerToken}{  "resource": "http://api.service.com/v1.0/files/file1.txt",  "notificationUrl": "https://contoso.com/myCallbacks",  "clientState": "clientOriginatedOpaqueToken"}</code></pre><p>服务应该响应这样的消息，其响应格式最低限度如下：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"32b8cbd6174ab18b"</span><span class="token punctuation">,</span>  <span class="token property">"expirationDateTime"</span><span class="token operator">:</span> <span class="token string">"2016-02-04T11:23Z"</span><span class="token punctuation">}</span></code></pre><p>下面是一个使用Application-Only主体的示例，其中应用程序正在查看其授权的所有文件：</p><pre class=" language-http"><code class="language-http">POST https://api.contoso.com/files/v1.0/$subscriptions HTTP 1.1<span class="token header-name keyword">Authorization:</span> Bearer {ApplicationPrincipalBearerToken}{  "resource": "All.Files",  "notificationUrl": "https://contoso.com/myCallbacks",  "clientState": "clientOriginatedOpaqueToken"}</code></pre><p>服务应该响应这样的消息，其响应格式最低限度如下：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"8cbd6174abb391179"</span><span class="token punctuation">,</span>  <span class="token property">"expirationDateTime"</span><span class="token operator">:</span> <span class="token string">"2016-02-04T11:23Z"</span><span class="token punctuation">}</span></code></pre><h4 id="15-7-2-Updating-subscriptions"><a href="#15-7-2-Updating-subscriptions" class="headerlink" title="15.7.2. Updating subscriptions"></a>15.7.2. Updating subscriptions</h4><p>服务可以支持修改订阅。<br>  要更新现有订阅的属性，客户端将使用提供ID和需要更改的属性的PATCH请求。<br>省略的属性将保留其值。<br>要删除属性，请为其指定值JSON null。</p><p>与创建一样，订阅也是单独管理的。</p><p>以下请求更改现有订阅的通知URL：</p><pre class=" language-http"><code class="language-http">PATCH https://api.contoso.com/files/v1.0/$subscriptions/{id} HTTP 1.1<span class="token header-name keyword">Authorization:</span> Bearer {UserPrincipalBearerToken}{  "notificationUrl": "https://contoso.com/myNewCallback"}</code></pre><p>如果PATCH请求包含新的_notificationUrl_，则服务器必须如上所述对其执行验证。<br>如果新URL无法验证，则服务必须使PATCH请求失败并使订阅保持其先前状态。</p><p>该服务必须返回一个空体和“204 No Content”来表示一个成功的补丁。</p><p>如果补丁失败，服务必须返回错误正文和状态代码。</p><p>操作必须成功或原子化失败。</p><h4 id="15-7-3-Deleting-subscriptions"><a href="#15-7-3-Deleting-subscriptions" class="headerlink" title="15.7.3. Deleting subscriptions"></a>15.7.3. Deleting subscriptions</h4><p>服务必须支持删除订阅。<br>可以通过对订阅资源发出DELETE请求来删除现有订阅：</p><pre class=" language-http"><code class="language-http">DELETE https://api.contoso.com/files/v1.0/$subscriptions/{id} HTTP 1.1<span class="token header-name keyword">Authorization:</span> Bearer {UserPrincipalBearerToken}</code></pre><p>与更新一样，服务必须返回“204 No Content”以成功删除，或者返回错误正文和状态代码以指示失败。</p><h4 id="15-7-4-Enumerating-subscriptions"><a href="#15-7-4-Enumerating-subscriptions" class="headerlink" title="15.7.4. Enumerating subscriptions"></a>15.7.4. Enumerating subscriptions</h4><p>要获取活动订阅列表，客户端使用User + Application或Application-Only bearer token对订阅资源发出GET请求：</p><pre class=" language-http"><code class="language-http">GET https://api.contoso.com/files/v1.0/$subscriptions HTTP 1.1<span class="token header-name keyword">Authorization:</span> Bearer {UserPrincipalBearerToken}</code></pre><p>服务必须使用User + Application主承载令牌返回如下格式：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"value"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"32b8cbd6174ab18b"</span><span class="token punctuation">,</span>      <span class="token property">"resource"</span><span class="token operator">:</span> <span class="token string">" http://api.contoso.com/v1.0/files/file1.txt"</span><span class="token punctuation">,</span>      <span class="token property">"notificationUrl"</span><span class="token operator">:</span> <span class="token string">"https://contoso.com/myCallbacks"</span><span class="token punctuation">,</span>      <span class="token property">"clientState"</span><span class="token operator">:</span> <span class="token string">"clientOriginatedOpaqueToken"</span><span class="token punctuation">,</span>      <span class="token property">"expirationDateTime"</span><span class="token operator">:</span> <span class="token string">"2016-02-04T11:23Z"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>可以使用仅应用程序主承载令牌返回的示例：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"value"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"6174ab18bfa22"</span><span class="token punctuation">,</span>      <span class="token property">"resource"</span><span class="token operator">:</span> <span class="token string">"All.Files "</span><span class="token punctuation">,</span>      <span class="token property">"notificationUrl"</span><span class="token operator">:</span> <span class="token string">"https://contoso.com/myCallbacks"</span><span class="token punctuation">,</span>      <span class="token property">"clientState"</span><span class="token operator">:</span> <span class="token string">"clientOriginatedOpaqueToken"</span><span class="token punctuation">,</span>      <span class="token property">"expirationDateTime"</span><span class="token operator">:</span> <span class="token string">"2016-02-04T11:23Z"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="15-8-Security"><a href="#15-8-Security" class="headerlink" title="15.8. Security"></a>15.8. Security</h3><p>所有服务URL都必须是HTTPS（即所有入站调用必须是HTTPS）。处理Web Hooks的服务必须接受HTTPS。</p><p>我们建议允许客户端定义的Web Hook回调URL的服务不应该通过HTTP传输数据。<br>这是因为可能会通过客户端，网络，服务器日志和其他机制无意中暴露信息。</p><p>但是，由于客户端端点或软件限制，有些情况下无法遵循上述建议。<br>因此，服务可以允许HTTP钩子URL。</p><p>此外，允许客户端定义的HTTP Web挂钩回调URL的服务应该符合工程领导指定的隐私策略。<br>这通常包括建议客户更喜欢SSL连接并遵守特殊预防措施，以确保正确处理日志和其他服务数据收集。</p><p>例如，服务可能不希望开发人员为板载生成证书。<br>服务可能只在测试帐户上启用此功能。</p><h2 id="16-Unsupported-requests"><a href="#16-Unsupported-requests" class="headerlink" title="16. Unsupported requests"></a>16. Unsupported requests</h2><p>RESTful API客户端可以请求当前不受支持的功能。<br>RESTful API必须响应与本节一致的有效但不受支持的请求。</p><h3 id="16-1-Essential-guidance"><a href="#16-1-Essential-guidance" class="headerlink" title="16.1. Essential guidance"></a>16.1. Essential guidance</h3><p>RESTful API通常会选择限制客户端可以执行的功能。<br>例如，审计系统允许创建记录但不修改或删除记录。<br>类似地，一些API将公开集合但需要或以其他方式限制过滤和排序标准，或者可能不支持客户端驱动的分页。</p><h3 id="16-2-Feature-allow-list"><a href="#16-2-Feature-allow-list" class="headerlink" title="16.2. Feature allow list"></a>16.2. Feature allow list</h3><p>如果服务不支持以下任何API功能，则必须在呼叫者请求功能时提供错误响应。<br>功能是：</p><ul><li>集合中的密钥寻址，例如：<code>https://api.contoso.com/v1.0/people/user1@contoso.com</code></li><li>按属性值过滤集合，例如：<code>https://api.contoso.com/v1.0/people?$filter=name eq &#39;david&#39;</code></li><li>按范围过滤集合，例如：<code>http://api.contoso.com/v1.0/people?$filter=hireDate ge 2014-01-01和hireDate le 2014-12-31</code></li><li>通过$ top和$ skip进行客户驱动的分页，例如：<code>http：//api.contoso.com/v1.0/people？$ top = 5＆$ skip = 2</code></li><li>按$ orderBy排序，例如：<code>https://api.contoso.com/v1.0/people?$orderBy=name desc</code></li><li>提供$ delta令牌，例如：<code>https://api.contoso.com/v1.0/people?$delta</code></li></ul><h4 id="16-2-1-Error-response"><a href="#16-2-1-Error-response" class="headerlink" title="16.2.1. Error response"></a>16.2.1. Error response</h4><p>如果调用者请求功能允许列表中找到不受支持的功能，则服务必须提供错误响应。<br>错误响应必须是来自4xx系列的HTTP状态代码，表示无法满足请求。<br>除非更具体的错误状态适用于给定的请求，否则服务应该返回“400 Bad Request”和符合Microsoft REST API准则中提供的错误响应指南的错误有效负载。<br>服务应该在响应消息中包含足够的详细信息，以便开发人员确切地确定不支持请求的哪个部分。</p><p>Example:</p><pre class=" language-http"><code class="language-http"><span class="token request-line"><span class="token property">GET</span> https://api.contoso.com/v1.0/people?$orderBy=name HTTP/1.1</span><span class="token header-name keyword">Accept:</span> application/json</code></pre><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">400 Bad Request</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token string">"error"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"code"</span><span class="token punctuation">:</span> <span class="token string">"ErrorUnsupportedOrderBy"</span><span class="token punctuation">,</span>    <span class="token string">"message"</span><span class="token punctuation">:</span> <span class="token string">"Ordering by name is not supported."</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span></code></pre><h2 id="17-Naming-guidelines"><a href="#17-Naming-guidelines" class="headerlink" title="17. Naming guidelines"></a>17. Naming guidelines</h2><h3 id="17-1-Approach"><a href="#17-1-Approach" class="headerlink" title="17.1. Approach"></a>17.1. Approach</h3><p>命名策略应该有助于开发人员发现功能，而无需经常参考文档。<br>使用通用模式和标准约定极大地帮助开发人员正确猜测公共属性名称和含义。<br>服务应该使用详细的命名模式，并且不应该使用缩写词而不是首字母缩略词，这些缩写词是API所代表的域中的主要表达方式（例如Url）。</p><h3 id="17-2-Casing"><a href="#17-2-Casing" class="headerlink" title="17.2. Casing"></a>17.2. Casing</h3><ul><li>首字母缩略词应该遵循套管约定，就像它们是常规词（例如Url）一样。</li><li>所有标识符包括名称空间，实体类型，实体集，属性，操作，函数和枚举值应该使用lowerCamelCase。</li><li>HTTP标头是例外，并且应该使用Capitalized-Hyphenated-Terms的标准HTTP约定。</li></ul><h3 id="17-3-Names-to-avoid"><a href="#17-3-Names-to-avoid" class="headerlink" title="17.3. Names to avoid"></a>17.3. Names to avoid</h3><p>某些名称在API域中过载，以至于它们失去了所有含义，或者与使用REST API（例如OAUTH）时无法避免的域中的其他常见用法发生冲突。<br>服务不应使用以下名称：</p><ul><li>背景</li><li>范围</li><li>资源</li></ul><h3 id="17-4-Forming-compound-names"><a href="#17-4-Forming-compound-names" class="headerlink" title="17.4. Forming compound names"></a>17.4. Forming compound names</h3><ul><li>服务应该避免使用诸如’a’，’the’，’of’之类的文章，除非需要传达意义。</li><li>例如 不应该使用诸如 a User，theAccount，countOfBooks 之类的名称，而应该首选user，account，bookCount。</li><li>服务应该在不这样做时向属性名称添加类型会导致数据如何表示模糊或者导致服务不使用公共属性名称。</li><li>在属性名称中添加类型时，服务必须在末尾添加类型，例如createdDateTime。</li></ul><h3 id="17-5-Identity-properties"><a href="#17-5-Identity-properties" class="headerlink" title="17.5. Identity properties"></a>17.5. Identity properties</h3><ul><li>服务必须为标识属性使用字符串类型。</li><li>对于OData服务，服务必须使用OData @id属性来表示资源的规范标识符。</li><li>服务可以使用简单的“id”属性来表示资源的本地或遗留主键值。</li><li>服务应该使用后缀为“Id”的关系名称来表示另一个资源的外键，例如：subscriptionId。</li><li>此属性的内容应该是引用资源的规范ID。</li></ul><h3 id="17-6-Date-and-time-properties"><a href="#17-6-Date-and-time-properties" class="headerlink" title="17.6. Date and time properties"></a>17.6. Date and time properties</h3><ul><li>对于同时需要日期和时间的属性，服务必须使用后缀“DateTime”。</li><li>对于只需要日期信息而不指定时间的属性，服务必须使用后缀“date”，例如birthDate。</li><li>对于只需要时间信息而没有指定日期的属性，服务必须使用后缀“time”，例如appointment mentstarttime。</li></ul><h3 id="17-7-Name-properties"><a href="#17-7-Name-properties" class="headerlink" title="17.7. Name properties"></a>17.7. Name properties</h3><ul><li>对于通常显示给用户的资源的整体名称，服务必须使用属性名称“displayName”。</li><li>服务可能使用其他通用命名属性，例如givenName、姓氏、signInName。</li></ul><h3 id="17-8-Collections-and-counts"><a href="#17-8-Collections-and-counts" class="headerlink" title="17.8. Collections and counts"></a>17.8. Collections and counts</h3><ul><li>服务必须使用正确的英语将集合命名为复数名词或复数名词短语。</li><li>服务可使用简化英语的名词，有复数，不常见的口头使用。</li><li>例如，可以使用模式而不是模式。</li><li>服务必须用一个或多个后缀为“Count”的名词短语来命名资源计数。</li></ul><h3 id="17-9-Common-property-names"><a href="#17-9-Common-property-names" class="headerlink" title="17.9. Common property names"></a>17.9. Common property names</h3><p>如果服务有属性，其数据与下面的名称匹配，则服务必须使用该表中的名称。<br>随着服务添加更常用的术语，该表将会增长。<br>添加此类术语的服务所有者应该建议在本文档中添加这些术语。</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>attendees</td></tr><tr><td>body</td></tr><tr><td>createdDateTime</td></tr><tr><td>childCount</td></tr><tr><td>children</td></tr><tr><td>contentUrl</td></tr><tr><td>country</td></tr><tr><td>createdBy</td></tr><tr><td>displayName</td></tr><tr><td>errorUrl</td></tr><tr><td>eTag</td></tr><tr><td>event</td></tr><tr><td>expirationDateTime</td></tr><tr><td>givenName</td></tr><tr><td>jobTitle</td></tr><tr><td>kind</td></tr><tr><td>id</td></tr><tr><td>lastModifiedDateTime</td></tr><tr><td>location</td></tr><tr><td>memberOf</td></tr><tr><td>message</td></tr><tr><td>name</td></tr><tr><td>owner</td></tr><tr><td>people</td></tr><tr><td>person</td></tr><tr><td>postalCode</td></tr><tr><td>photo</td></tr><tr><td>preferredLanguage</td></tr><tr><td>properties</td></tr><tr><td>signInName</td></tr><tr><td>surname</td></tr><tr><td>tags</td></tr><tr><td>userPrincipalName</td></tr><tr><td>webUrl</td></tr></tbody></table><h2 id="18-Appendix"><a href="#18-Appendix" class="headerlink" title="18. Appendix"></a>18. Appendix</h2><h3 id="18-1-Sequence-diagram-notes"><a href="#18-1-Sequence-diagram-notes" class="headerlink" title="18.1. Sequence diagram notes"></a>18.1. Sequence diagram notes</h3><p>本文档中的所有序列图均使用WebSequenceDiagrams.com网站生成。 要生成它们，请将以下文本粘贴到Web工具中。</p><h4 id="18-1-1-Push-notifications-per-user-flow"><a href="#18-1-1-Push-notifications-per-user-flow" class="headerlink" title="18.1.1. Push notifications, per user flow"></a>18.1.1. Push notifications, per user flow</h4><pre><code>=== Begin Text ===note over Developer, Automation, App Server:     An App Developer like MovieMaker     Wants to integrate with primary service like Dropboxend notenote over DB Portal, DB App Registration, DB Notifications, DB Auth, DB Service: The primary service like Dropboxnote over Client: The end users&#39; browser or installed appnote over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Manual App RegistrationDeveloper &lt;--&gt; DB Portal : Login into Portal, App Registration UXDB Portal -&gt; +DB App Registration: App Name etc.note over DB App Registration: Confirm Portal Access TokenDB App Registration -&gt; -DB Portal: App IDDB Portal &lt;--&gt; App Server: Developer copies App IDnote over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Manual Notification RegistrationDeveloper &lt;--&gt; DB Portal: webhook registration UXDB Portal -&gt; +DB Notifications: Register: App Server webhook URL, Scope, App IDNote over DB Notifications : Confirm Portal Access TokenDB Notifications -&gt; -DB Portal: notification IDDB Portal --&gt; App Server : Developer may copy notification IDnote over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Client AuthorizationClient -&gt; +App Server : Request access to DB protected informationApp Server -&gt; -Client : Redirect to DB Authorization endpoint with authorization requestClient -&gt; +DB Auth : Redirected authorization requestClient &lt;--&gt; DB Auth : Authorization UXDB Auth -&gt; -Client : Redirect back to App Server with codeClient -&gt; +App Server : Redirect request back to access server with access codeApp Server -&gt; +DB Auth : Request tokens with access codenote right of DB Service: Cache that this User ID provided access to App IDDB Auth -&gt; -App Server : Response with access, refresh, and ID tokensnote right of App Server : Cache tokens by user IDApp Server -&gt; -Client : Return information to clientnote over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Notification FlowClient &lt;--&gt; DB Service: Changes to user data - typical via interacting with App Server via ClientDB Service -&gt; App Server : Notification with notification ID and user IDApp Server -&gt; +DB Service : Request changed information with cached access tokens and &quot;since&quot; tokennote over DB Service: Confirm User Access TokenDB Service -&gt; -App Server : Response with data and new &quot;since&quot; tokennote right of App Server: Update status and cache new &quot;since&quot; token=== End Text ===</code></pre><h4 id="18-1-2-Push-notifications-firehose-flow"><a href="#18-1-2-Push-notifications-firehose-flow" class="headerlink" title="18.1.2. Push notifications, firehose flow"></a>18.1.2. Push notifications, firehose flow</h4><h4 id="18-1-2-Push-notifications-firehose-flow-1"><a href="#18-1-2-Push-notifications-firehose-flow-1" class="headerlink" title="18.1.2. Push notifications, firehose flow"></a>18.1.2. Push notifications, firehose flow</h4><pre><code>=== Begin Text ===note over Developer, Automation, App Server:     An App Developer like MovieMaker     Wants to integrate with primary service like Dropboxend notenote over DB Portal, DB App Registration, DB Notifications, DB Auth, DB Service: The primary service like Dropboxnote over Client: The end users&#39; browser or installed appnote over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : App Registrationalt Automated app registration   Developer &lt;--&gt; Automation: Configure   Automation -&gt; +DB App Registration: App Name etc.   note over DB App Registration: Confirm App Access Token   DB App Registration -&gt; -Automation: App ID, App Secret   Automation --&gt; App Server : Embed App ID, App Secretelse Manual app registration   Developer &lt;--&gt; DB Portal : Login into Portal, App Registration UX   DB Portal -&gt; +DB App Registration: App Name etc.   note over DB App Registration: Confirm Portal Access Token   DB App Registration -&gt; -DB Portal: App ID   DB Portal &lt;--&gt; App Server: Developer copies App IDendnote over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Client AuthorizationClient -&gt; +App Server : Request access to DB protected informationApp Server -&gt; -Client : Redirect to DB Authorization endpoint with authorization requestClient -&gt; +DB Auth : Redirected authorization requestClient &lt;--&gt; DB Auth : Authorization UXDB Auth -&gt; -Client : Redirect back to App Server with codeClient -&gt; +App Server : Redirect request back to access server with access codeApp Server -&gt; +DB Auth : Request tokens with access codenote right of DB Service: Cache that this User ID provided access to App IDDB Auth -&gt; -App Server : Response with access, refresh, and ID tokensnote right of App Server : Cache tokens by user IDApp Server -&gt; -Client : Return information to clientnote over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Notification RegistrationApp Server-&gt;+DB Notifications: Register: App server webhook URL, Scope, App IDnote over DB Notifications : Confirm User Access TokenDB Notifications -&gt; -App Server: notification IDnote right of App Server : Cache the Notification ID and User Access Tokennote over Developer, Automation, App Server, DB Portal, DB App Registration, DB Notifications, Client : Notification FlowClient &lt;--&gt; DB Service: Changes to user data - typical via interacting with App Server via ClientDB Service -&gt; App Server : Notification with notification ID and user IDApp Server -&gt; +DB Service : Request changed information with cached access tokens and &quot;since&quot; tokennote over DB Service: Confirm User Access TokenDB Service -&gt; -App Server : Response with data and new &quot;since&quot; tokennote right of App Server: Update status and cache new &quot;since&quot; token=== End Text ===</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microsoft REST API指南中文翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社区发帖指南</title>
      <link href="/2019/07/02/%E7%A4%BE%E5%8C%BA%E5%8F%91%E5%B8%96%E6%8C%87%E5%8D%97/"/>
      <url>/2019/07/02/%E7%A4%BE%E5%8C%BA%E5%8F%91%E5%B8%96%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="社区发帖指南"><a href="#社区发帖指南" class="headerlink" title="社区发帖指南"></a>社区发帖指南</h1><p>社区网站基于hexo进行搭建，内容托管在github，基于docker进行自动构建。在开始之前，您需要了解以下内容：</p><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>社区官网：<a href="http://hn-tech.net/" target="_blank" rel="noopener">http://hn-tech.net/</a></p><p>代码库（<strong>社区官网基于此库自动构建</strong>）：<a href="https://github.com/china-net-community/OfficialWebsite" target="_blank" rel="noopener">https://github.com/china-net-community/OfficialWebsite</a></p><h2 id="仅提交内容（发帖）"><a href="#仅提交内容（发帖）" class="headerlink" title="仅提交内容（发帖）"></a>仅提交内容（发帖）</h2><h3 id="必备技能"><a href="#必备技能" class="headerlink" title="必备技能"></a>必备技能</h3><table><thead><tr><th>技能</th><th align="left">说明</th></tr></thead><tbody><tr><td>git</td><td align="left">需要使用git提交内容，教程：<a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/git/git-tutorial.html</a></td></tr><tr><td>Markdown</td><td align="left">需要使用Markdown语法编写内容，参考：<a href="https://www.w3cschool.cn/markdownyfsm/" target="_blank" rel="noopener">https://www.w3cschool.cn/markdownyfsm/</a></td></tr><tr><td>pull request（以下简称pr）</td><td align="left">需要提交pr，待管理员审核，参考：<a href="https://help.github.com/cn/articles/creating-a-pull-request" target="_blank" rel="noopener">https://help.github.com/cn/articles/creating-a-pull-request</a></td></tr></tbody></table><h3 id="发帖目录说明"><a href="#发帖目录说明" class="headerlink" title="发帖目录说明"></a>发帖目录说明</h3><p>网站主要内容目录如下图所示：<br><img src="/res/%E7%9B%AE%E5%BD%95.png" alt="内容目录"></p><p>主体目录如下：</p><table><thead><tr><th>目录</th><th align="left">说明</th></tr></thead><tbody><tr><td>_posts</td><td align="left">内容目录，也就是帖子目录，所有Markdown文件请按照目录分类进行提交</td></tr><tr><td>res</td><td align="left">图片资源目录</td></tr></tbody></table><p>帖子目录目前如下所示，具体要求请参考该分类下的说明：</p><table><thead><tr><th>目录</th><th align="left">说明</th></tr></thead><tbody><tr><td>家务</td><td align="left"></td></tr><tr><td>开源</td><td align="left">社区开源库、开源计划说明</td></tr><tr><td>招聘</td><td align="left">社区招聘内容</td></tr><tr><td>活动</td><td align="left">社区活动内容</td></tr></tbody></table><h3 id="提交（发帖）流程"><a href="#提交（发帖）流程" class="headerlink" title="提交（发帖）流程"></a>提交（发帖）流程</h3><p>以下为社区发帖的初步流程：</p><ol><li>从<a href="https://github.com/china-net-community" target="_blank" rel="noopener">https://github.com/china-net-community</a>创建pr</li><li>使用Visual Studio Code（推荐）添加或编辑相关的Markdown文档</li><li>签入并推送内容</li><li>通知管理员审核（@微信群、QQ群），由于大家都是兼职，请耐心等待</li><li>审核通过后2~5分钟会自动更新内容</li></ol><h3 id="帖子顶部变量设置说明"><a href="#帖子顶部变量设置说明" class="headerlink" title="帖子顶部变量设置说明"></a>帖子顶部变量设置说明</h3><table><thead><tr><th>参数</th><th align="center">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td>layout</td><td align="center">布局</td><td align="left"></td></tr><tr><td>title</td><td align="center">文章标题，强烈建议填写此选项</td><td align="left"></td></tr><tr><td>date</td><td align="center">发布时间，强烈建议填写此选项，且最好保证全局唯一</td><td align="left"></td></tr><tr><td>updated</td><td align="center">更新日期</td><td align="left">文件更新日期</td></tr><tr><td>comments</td><td align="center">开启文章的评论功能</td><td align="left">true</td></tr><tr><td>tags</td><td align="center">标签（不适用于分页）</td><td align="left"></td></tr><tr><td>categories</td><td align="center">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td><td align="left"></td></tr><tr><td>permalink</td><td align="center">覆盖文章网址</td><td align="left"></td></tr><tr><td>author</td><td align="center">作者</td><td align="left"></td></tr><tr><td>img</td><td align="center">列表封面图</td><td align="left"></td></tr><tr><td>top</td><td align="center">推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章</td><td align="left">false</td></tr><tr><td>cover</td><td align="center">表示该文章是否需要加入到首页轮播封面中</td><td align="left">false</td></tr><tr><td>coverImg</td><td align="center">表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td><td align="left"></td></tr><tr><td>password</td><td align="center">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项</td><td align="left"></td></tr><tr><td>toc</td><td align="center">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项</td><td align="left">true</td></tr><tr><td>mathjax</td><td align="center">是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td><td align="left">false</td></tr><tr><td>summary</td><td align="center">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td><td align="left"></td></tr></tbody></table><p>参考示例：</p><pre class=" language-yml"><code class="language-yml">---title: 社区发帖指南author: 李文强img: /res/20190702143924.pngtop: truecover: truetoc: truemathjax: falsesummary: 社区发帖指南，请严格按照要求进行发帖。date: 2019-07-02 19:31:59tags:  - 发帖必读categories:  - 公告---</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="如何设置代码高亮？"><a href="#如何设置代码高亮？" class="headerlink" title="如何设置代码高亮？"></a>如何设置代码高亮？</h4><p>C#代码高亮设置如下所示：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token function">stringNormalizeKey</span><span class="token punctuation">(</span><span class="token keyword">string</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> key<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token string">"__"</span><span class="token punctuation">,</span>ConfigurationPath<span class="token punctuation">.</span>KeyDelimiter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/res/20190702162422.png" alt="C#代码高亮参考"></p><p>支持的编程语言：<br><img src="/res/20190702143924.png" alt="C#支持的编程语言："></p><p>完整支持见：<a href="https://prismjs.com/#supported-languages" target="_blank" rel="noopener">https://prismjs.com/#supported-languages</a></p><h2 id="进阶内容（帮忙一起改网站）"><a href="#进阶内容（帮忙一起改网站）" class="headerlink" title="进阶内容（帮忙一起改网站）"></a>进阶内容（帮忙一起改网站）</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><table><thead><tr><th>技能</th><th align="center">说明</th></tr></thead><tbody><tr><td>前端</td><td align="center">hexo很灵活，主题内容均可修改。</td></tr><tr><td>hexo</td><td align="center">hexo是一个快速、简洁且高效的博客框架，您如果需要参与社区网站建设，需要对hexo有一定的了解。hexo官网：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></td></tr><tr><td>docker</td><td align="center">使用docker进行构建，可选</td></tr></tbody></table><h3 id="主题说明"><a href="#主题说明" class="headerlink" title="主题说明"></a>主题说明</h3><p>网站使用了hexo-theme-matery主题，具体见：<br><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery</a></p>]]></content>
      
      
      <categories>
          
          <category> 公告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发帖必读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2019/07/01/%E6%8A%80%E6%9C%AF%E8%AE%BA%E5%9D%9B/test/"/>
      <url>/2019/07/01/%E6%8A%80%E6%9C%AF%E8%AE%BA%E5%9D%9B/test/</url>
      
        <content type="html"><![CDATA[<p>test</p>]]></content>
      
      
      <categories>
          
          <category> 技术论坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术论坛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2019/07/01/%E8%81%8C%E5%9C%BA%E5%8A%A0%E6%B2%B9%E7%AB%99/test/"/>
      <url>/2019/07/01/%E8%81%8C%E5%9C%BA%E5%8A%A0%E6%B2%B9%E7%AB%99/test/</url>
      
        <content type="html"><![CDATA[<p>test</p>]]></content>
      
      
      <categories>
          
          <category> 职场加油站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职场加油站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2019/07/01/%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%8E%A5/Magicodes.Admin/"/>
      <url>/2019/07/01/%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%8E%A5/Magicodes.Admin/</url>
      
        <content type="html"><![CDATA[<p>test</p>]]></content>
      
      
      <categories>
          
          <category> 项目对接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目对接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2019/07/01/%E4%BF%B1%E4%B9%90%E9%83%A8/PLM/test/"/>
      <url>/2019/07/01/%E4%BF%B1%E4%B9%90%E9%83%A8/PLM/test/</url>
      
        <content type="html"><![CDATA[<p>test</p>]]></content>
      
      
      <categories>
          
          <category> 俱乐部 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 俱乐部 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
